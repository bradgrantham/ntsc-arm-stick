#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#undef USE_PS2KBD
#undef USE_AUDIO
#define DO_WOLF

#include <stm32f7xx_hal.h>

#include "ff.h"

#include "defs.h"
#include "delay.h"
#include "leds.h"
#include "byte_queue.h"
#include "gpio_helpers.h"
#include "utility.h"
#include "crc7.h"
#include "logprintf.h"

#include "monitor_queue.h"
#include "console_queue.h"
#include "uart.h"
#include "sd_spi.h"
#include "keyboard.h"
#include "reset_button.h"

#define SECTION_CCMRAM __attribute__((section (".ccmram")))

// System APIs
#include "videomode.h"
#include "graphics.h"
#include "textport.h"
#include "rocinante.h"

// System driver internal definitions
#include "videomodeinternal.h"

static int gDumpKeyboardData = 0;

char gMonitorCommandBuffer[80];
unsigned char gMonitorCommandBufferLength = 0;

#define IOBOARD_FIRMWARE_VERSION_STRING XSTR(IOBOARD_FIRMWARE_VERSION)

volatile unsigned char gSerialInputToMonitor = 1;

void panic_worse()
{
    LED_set_panic(1);
    for(;;);
}

void panic(void)
{
    static int entered = 0;

    LED_set_panic(1);

    int pin = 0;
    for(;;) {
        if(!entered) {
            // SERIAL_flush() can itself panic(), so stop reentry here
            entered = 1;
            SERIAL_flush();
            entered = 0;
        }

        LED_set_panic(pin);
        pin = pin ? 0 : 1;
        delay_ms(100);
    }
}

//----------------------------------------------------------------------------
// System Initialization Goop

// DMA_TIM_CLOCKS should be SystemCoreClock / 14318180.0
// need main clock as close as possible to @ 171.816 if DMA_TIM_CLOCKS is 12

typedef struct {
    float CPUFreq;      // not used; computed
    uint32_t HSE;       // not used; fixed
    uint32_t PLL_M;
    uint32_t PLL_N;
    uint32_t PLL_P;
    uint32_t DMA_TIM_CLOCKS;
    float colorburstClock;      // not used; computed
    float error;      // not used; computed
} ClockConfiguration;

unsigned int whichConfig = 0;
static const ClockConfiguration clockConfigs[] =
{
    // Base mode we know works
    // {200.47, 16000000, 17, 426, 2, 14, 3.579832, 0.000080}, // 415 normal mode
    // {203.43, 16000000, 7, 178, 2, 7, 3.632653, 0.014837}, // maybe closer to correcting HSI than 3.682540?, ended up too fast
    // {206.22, 16000000, 9, 232, 2, 7, 3.682540, 0.028773}, // guessing close to correcting HSI, ended up too fast
    { 198.29, 16000000, 14, 347, 2, 7, 3.540816, -0.010819},
    // {214.77, 16000000, 13, 349, 2, 15, 3.579487, -0.000016}, // unstable in 415xx and TIM_CLOCKS wrong
    { 200.47, 16000000, 17, 426, 2, 8, 3.132353, -0.124930},
    { 200.50, 16000000, 16, 401, 2, 8, 3.132812, -0.124801},
    { 200.53, 16000000, 15, 376, 2, 8, 3.133333, -0.124656},
    { 200.57, 16000000, 14, 351, 2, 8, 3.133929, -0.124490},
    { 200.62, 16000000, 13, 326, 2, 8, 3.134615, -0.124298},
    { 200.67, 16000000, 12, 301, 2, 8, 3.135417, -0.124074},
    { 200.73, 16000000, 11, 276, 2, 8, 3.136364, -0.123809},
    { 200.80, 16000000, 10, 251, 2, 8, 3.137500, -0.123492},
    { 200.89, 16000000, 9, 226, 2, 8, 3.138889, -0.123104},
    { 200.94, 16000000, 17, 427, 2, 8, 3.139706, -0.122876},
    { 201.00, 16000000, 8, 201, 2, 8, 3.140625, -0.122619},
    { 201.00, 16000000, 16, 402, 2, 8, 3.140625, -0.122619},
    { 201.07, 16000000, 15, 377, 2, 8, 3.141667, -0.122328},
    { 201.14, 16000000, 7, 176, 2, 8, 3.142857, -0.121995},
    { 201.14, 16000000, 14, 352, 2, 8, 3.142857, -0.121995},
    { 201.23, 16000000, 13, 327, 2, 8, 3.144231, -0.121612},
    { 201.33, 16000000, 6, 151, 2, 8, 3.145833, -0.121164},
    { 201.33, 16000000, 12, 302, 2, 8, 3.145833, -0.121164},
    { 201.41, 16000000, 17, 428, 2, 8, 3.147059, -0.120822},
    { 201.45, 16000000, 11, 277, 2, 8, 3.147727, -0.120635},
    { 201.50, 16000000, 16, 403, 2, 8, 3.148438, -0.120436},
    { 201.60, 16000000, 5, 126, 2, 8, 3.150000, -0.120000},
    { 201.60, 16000000, 10, 252, 2, 8, 3.150000, -0.120000},
    { 201.60, 16000000, 15, 378, 2, 8, 3.150000, -0.120000},
    { 201.71, 16000000, 14, 353, 2, 8, 3.151786, -0.119501},
    { 201.78, 16000000, 9, 227, 2, 8, 3.152778, -0.119224},
    { 201.85, 16000000, 13, 328, 2, 8, 3.153846, -0.118925},
    { 201.88, 16000000, 17, 429, 2, 8, 3.154412, -0.118767},
    { 202.00, 16000000, 4, 101, 2, 8, 3.156250, -0.118254},
    { 202.00, 16000000, 8, 202, 2, 8, 3.156250, -0.118254},
    { 202.00, 16000000, 12, 303, 2, 8, 3.156250, -0.118254},
    { 202.00, 16000000, 16, 404, 2, 8, 3.156250, -0.118254},
    { 202.13, 16000000, 15, 379, 2, 8, 3.158333, -0.117672},
    { 202.18, 16000000, 11, 278, 2, 8, 3.159091, -0.117460},
    { 202.29, 16000000, 7, 177, 2, 8, 3.160714, -0.117007},
    { 202.29, 16000000, 14, 354, 2, 8, 3.160714, -0.117007},
    { 202.35, 16000000, 17, 430, 2, 8, 3.161765, -0.116713},
    { 202.40, 16000000, 10, 253, 2, 8, 3.162500, -0.116508},
    { 202.46, 16000000, 13, 329, 2, 8, 3.163462, -0.116239},
    { 202.50, 16000000, 16, 405, 2, 8, 3.164062, -0.116071},
    { 202.67, 16000000, 3, 76, 2, 8, 3.166667, -0.115344},
    { 202.67, 16000000, 6, 152, 2, 8, 3.166667, -0.115344},
    { 202.67, 16000000, 9, 228, 2, 8, 3.166667, -0.115344},
    { 202.67, 16000000, 12, 304, 2, 8, 3.166667, -0.115344},
    { 202.67, 16000000, 15, 380, 2, 8, 3.166667, -0.115344},
    { 202.82, 16000000, 17, 431, 2, 8, 3.169118, -0.114659},
    { 202.86, 16000000, 14, 355, 2, 8, 3.169643, -0.114512},
    { 202.91, 16000000, 11, 279, 2, 8, 3.170455, -0.114286},
    { 203.00, 16000000, 8, 203, 2, 8, 3.171875, -0.113889},
    { 203.00, 16000000, 16, 406, 2, 8, 3.171875, -0.113889},
    { 203.08, 16000000, 13, 330, 2, 8, 3.173077, -0.113553},
    { 203.20, 16000000, 5, 127, 2, 8, 3.175000, -0.113016},
    { 203.20, 16000000, 10, 254, 2, 8, 3.175000, -0.113016},
    { 203.20, 16000000, 15, 381, 2, 8, 3.175000, -0.113016},
    { 203.33, 16000000, 12, 305, 2, 8, 3.177083, -0.112434},
    { 203.43, 16000000, 7, 178, 2, 8, 3.178571, -0.112018},
    { 203.43, 16000000, 14, 356, 2, 8, 3.178571, -0.112018},
    { 203.50, 16000000, 16, 407, 2, 8, 3.179688, -0.111706},
    { 203.56, 16000000, 9, 229, 2, 8, 3.180556, -0.111464},
    { 203.64, 16000000, 11, 280, 2, 8, 3.181818, -0.111111},
    { 203.69, 16000000, 13, 331, 2, 8, 3.182692, -0.110867},
    { 203.73, 16000000, 15, 382, 2, 8, 3.183333, -0.110688},
    { 204.00, 16000000, 2, 51, 2, 8, 3.187500, -0.109524},
    { 204.00, 16000000, 4, 102, 2, 8, 3.187500, -0.109524},
    { 204.00, 16000000, 6, 153, 2, 8, 3.187500, -0.109524},
    { 204.00, 16000000, 8, 204, 2, 8, 3.187500, -0.109524},
    { 204.00, 16000000, 10, 255, 2, 8, 3.187500, -0.109524},
    { 204.00, 16000000, 12, 306, 2, 8, 3.187500, -0.109524},
    { 204.00, 16000000, 16, 408, 2, 8, 3.187500, -0.109524},
    { 204.00, 16000000, 14, 357, 2, 8, 3.187500, -0.109524},
    { 204.27, 16000000, 15, 383, 2, 8, 3.191667, -0.108360},
    { 204.31, 16000000, 13, 332, 2, 8, 3.192308, -0.108181},
    { 204.36, 16000000, 11, 281, 2, 8, 3.193182, -0.107936},
    { 204.44, 16000000, 9, 230, 2, 8, 3.194444, -0.107584},
    { 204.50, 16000000, 16, 409, 2, 8, 3.195312, -0.107341},
    { 204.57, 16000000, 7, 179, 2, 8, 3.196429, -0.107029},
    { 204.57, 16000000, 14, 358, 2, 8, 3.196429, -0.107029},
    { 204.67, 16000000, 12, 307, 2, 8, 3.197917, -0.106614},
    { 204.80, 16000000, 5, 128, 2, 8, 3.200000, -0.106032},
    { 204.80, 16000000, 10, 256, 2, 8, 3.200000, -0.106032},
    { 204.80, 16000000, 15, 384, 2, 8, 3.200000, -0.106032},
    { 204.92, 16000000, 13, 333, 2, 8, 3.201923, -0.105494},
    { 205.00, 16000000, 8, 205, 2, 8, 3.203125, -0.105159},
    { 205.00, 16000000, 16, 410, 2, 8, 3.203125, -0.105159},
    { 205.09, 16000000, 11, 282, 2, 8, 3.204545, -0.104762},
    { 205.14, 16000000, 14, 359, 2, 8, 3.205357, -0.104535},
    { 205.33, 16000000, 3, 77, 2, 8, 3.208333, -0.103704},
    { 205.33, 16000000, 6, 154, 2, 8, 3.208333, -0.103704},
    { 205.33, 16000000, 12, 308, 2, 8, 3.208333, -0.103704},
    { 205.33, 16000000, 9, 231, 2, 8, 3.208333, -0.103704},
    { 205.33, 16000000, 15, 385, 2, 8, 3.208333, -0.103704},
    { 205.50, 16000000, 16, 411, 2, 8, 3.210938, -0.102976},
    { 205.54, 16000000, 13, 334, 2, 8, 3.211538, -0.102808},
    { 205.60, 16000000, 10, 257, 2, 8, 3.212500, -0.102540},
    { 205.71, 16000000, 7, 180, 2, 8, 3.214286, -0.102041},
    { 205.71, 16000000, 14, 360, 2, 8, 3.214286, -0.102041},
    { 180.00, 16000000, 14, 315, 2, 7, 3.214286, -0.102041},
    { 205.82, 16000000, 11, 283, 2, 8, 3.215909, -0.101587},
    { 205.87, 16000000, 15, 386, 2, 8, 3.216667, -0.101376},
    { 180.21, 16000000, 19, 428, 2, 7, 3.218045, -0.100990},
    { 180.24, 16000000, 17, 383, 2, 7, 3.218487, -0.100867},
    { 206.00, 16000000, 4, 103, 2, 8, 3.218750, -0.100794},
    { 206.00, 16000000, 8, 206, 2, 8, 3.218750, -0.100794},
    { 206.00, 16000000, 12, 309, 2, 8, 3.218750, -0.100794},
    { 206.00, 16000000, 16, 412, 2, 8, 3.218750, -0.100794},
    { 180.27, 16000000, 15, 338, 2, 7, 3.219048, -0.100710},
    { 180.31, 16000000, 13, 293, 2, 7, 3.219780, -0.100506},
    { 180.36, 16000000, 11, 248, 2, 7, 3.220779, -0.100227},
    { 206.15, 16000000, 13, 335, 2, 8, 3.221154, -0.100122},
    { 206.22, 16000000, 9, 232, 2, 8, 3.222222, -0.099824},
    { 180.44, 16000000, 9, 203, 2, 7, 3.222222, -0.099824},
    { 180.44, 16000000, 18, 406, 2, 7, 3.222222, -0.099824},
    { 206.29, 16000000, 14, 361, 2, 8, 3.223214, -0.099546},
    { 180.50, 16000000, 16, 361, 2, 7, 3.223214, -0.099546},
    { 180.57, 16000000, 7, 158, 2, 7, 3.224490, -0.099190},
    { 180.57, 16000000, 14, 316, 2, 7, 3.224490, -0.099190},
    { 206.40, 16000000, 5, 129, 2, 8, 3.225000, -0.099048},
    { 206.40, 16000000, 10, 258, 2, 8, 3.225000, -0.099048},
    { 206.40, 16000000, 15, 387, 2, 8, 3.225000, -0.099048},
    { 180.63, 16000000, 19, 429, 2, 7, 3.225564, -0.098890},
    { 180.67, 16000000, 12, 271, 2, 7, 3.226190, -0.098715},
    { 206.50, 16000000, 16, 413, 2, 8, 3.226562, -0.098611},
    { 180.71, 16000000, 17, 384, 2, 7, 3.226891, -0.098519},
    { 206.55, 16000000, 11, 284, 2, 8, 3.227273, -0.098413},
    { 180.80, 16000000, 5, 113, 2, 7, 3.228571, -0.098050},
    { 180.80, 16000000, 10, 226, 2, 7, 3.228571, -0.098050},
    { 180.80, 16000000, 15, 339, 2, 7, 3.228571, -0.098050},
    { 206.67, 16000000, 6, 155, 2, 8, 3.229167, -0.097883},
    { 206.67, 16000000, 12, 310, 2, 8, 3.229167, -0.097883},
    { 180.89, 16000000, 18, 407, 2, 7, 3.230159, -0.097606},
    { 206.77, 16000000, 13, 336, 2, 8, 3.230769, -0.097436},
    { 180.92, 16000000, 13, 294, 2, 7, 3.230769, -0.097436},
    { 206.86, 16000000, 7, 181, 2, 8, 3.232143, -0.097052},
    { 181.00, 16000000, 8, 181, 2, 7, 3.232143, -0.097052},
    { 206.86, 16000000, 14, 362, 2, 8, 3.232143, -0.097052},
    { 181.00, 16000000, 16, 362, 2, 7, 3.232143, -0.097052},
    { 181.05, 16000000, 19, 430, 2, 7, 3.233083, -0.096789},
    { 206.93, 16000000, 15, 388, 2, 8, 3.233333, -0.096719},
    { 181.09, 16000000, 11, 249, 2, 7, 3.233766, -0.096599},
    { 207.00, 16000000, 8, 207, 2, 8, 3.234375, -0.096428},
    { 207.00, 16000000, 16, 414, 2, 8, 3.234375, -0.096428},
    { 181.14, 16000000, 14, 317, 2, 7, 3.234694, -0.096339},
    { 181.18, 16000000, 17, 385, 2, 7, 3.235294, -0.096172},
    { 207.11, 16000000, 9, 233, 2, 8, 3.236111, -0.095943},
    { 207.20, 16000000, 10, 259, 2, 8, 3.237500, -0.095555},
    { 181.33, 16000000, 3, 68, 2, 7, 3.238095, -0.095389},
    { 181.33, 16000000, 6, 136, 2, 7, 3.238095, -0.095389},
    { 181.33, 16000000, 12, 272, 2, 7, 3.238095, -0.095389},
    { 181.33, 16000000, 9, 204, 2, 7, 3.238095, -0.095389},
    { 181.33, 16000000, 15, 340, 2, 7, 3.238095, -0.095389},
    { 181.33, 16000000, 18, 408, 2, 7, 3.238095, -0.095389},
    { 207.27, 16000000, 11, 285, 2, 8, 3.238636, -0.095238},
    { 207.33, 16000000, 12, 311, 2, 8, 3.239583, -0.094973},
    { 207.38, 16000000, 13, 337, 2, 8, 3.240385, -0.094750},
    { 181.47, 16000000, 19, 431, 2, 7, 3.240602, -0.094689},
    { 207.43, 16000000, 14, 363, 2, 8, 3.241071, -0.094558},
    { 181.50, 16000000, 16, 363, 2, 7, 3.241071, -0.094558},
    { 207.47, 16000000, 15, 389, 2, 8, 3.241667, -0.094391},
    { 181.54, 16000000, 13, 295, 2, 7, 3.241758, -0.094366},
    { 207.50, 16000000, 16, 415, 2, 8, 3.242188, -0.094246},
    { 181.60, 16000000, 10, 227, 2, 7, 3.242857, -0.094059},
    { 181.65, 16000000, 17, 386, 2, 7, 3.243697, -0.093824},
    { 181.71, 16000000, 7, 159, 2, 7, 3.244898, -0.093489},
    { 181.71, 16000000, 14, 318, 2, 7, 3.244898, -0.093489},
    { 181.78, 16000000, 18, 409, 2, 7, 3.246032, -0.093172},
    { 181.82, 16000000, 11, 250, 2, 7, 3.246753, -0.092970},
    { 181.87, 16000000, 15, 341, 2, 7, 3.247619, -0.092729},
    { 208.00, 16000000, 2, 52, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 3, 78, 2, 8, 3.250000, -0.092063},
    { 182.00, 16000000, 4, 91, 2, 7, 3.250000, -0.092063},
    { 208.00, 16000000, 4, 104, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 5, 130, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 6, 156, 2, 8, 3.250000, -0.092063},
    { 182.00, 16000000, 8, 182, 2, 7, 3.250000, -0.092063},
    { 208.00, 16000000, 8, 208, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 9, 234, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 10, 260, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 11, 286, 2, 8, 3.250000, -0.092063},
    { 182.00, 16000000, 12, 273, 2, 7, 3.250000, -0.092063},
    { 208.00, 16000000, 12, 312, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 13, 338, 2, 8, 3.250000, -0.092063},
    { 182.00, 16000000, 16, 364, 2, 7, 3.250000, -0.092063},
    { 208.00, 16000000, 16, 416, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 7, 182, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 14, 364, 2, 8, 3.250000, -0.092063},
    { 208.00, 16000000, 15, 390, 2, 8, 3.250000, -0.092063},
    { 182.12, 16000000, 17, 387, 2, 7, 3.252101, -0.091476},
    { 182.15, 16000000, 13, 296, 2, 7, 3.252747, -0.091296},
    { 182.22, 16000000, 9, 205, 2, 7, 3.253968, -0.090955},
    { 182.22, 16000000, 18, 410, 2, 7, 3.253968, -0.090955},
    { 182.29, 16000000, 14, 319, 2, 7, 3.255102, -0.090638},
    { 182.40, 16000000, 5, 114, 2, 7, 3.257143, -0.090068},
    { 182.40, 16000000, 10, 228, 2, 7, 3.257143, -0.090068},
    { 182.40, 16000000, 15, 342, 2, 7, 3.257143, -0.090068},
    { 208.50, 16000000, 16, 417, 2, 8, 3.257812, -0.089881},
    { 208.53, 16000000, 15, 391, 2, 8, 3.258333, -0.089735},
    { 182.50, 16000000, 16, 365, 2, 7, 3.258929, -0.089569},
    { 208.57, 16000000, 14, 365, 2, 8, 3.258929, -0.089569},
    { 208.62, 16000000, 13, 339, 2, 8, 3.259615, -0.089377},
    { 182.55, 16000000, 11, 251, 2, 7, 3.259740, -0.089342},
    { 208.67, 16000000, 12, 313, 2, 8, 3.260417, -0.089153},
    { 182.59, 16000000, 17, 388, 2, 7, 3.260504, -0.089129},
    { 208.73, 16000000, 11, 287, 2, 8, 3.261364, -0.088889},
    { 182.67, 16000000, 6, 137, 2, 7, 3.261905, -0.088738},
    { 182.67, 16000000, 12, 274, 2, 7, 3.261905, -0.088738},
    { 182.67, 16000000, 18, 411, 2, 7, 3.261905, -0.088738},
    { 208.80, 16000000, 10, 261, 2, 8, 3.262500, -0.088571},
    { 182.77, 16000000, 13, 297, 2, 7, 3.263736, -0.088226},
    { 208.89, 16000000, 9, 235, 2, 8, 3.263889, -0.088183},
    { 182.86, 16000000, 7, 160, 2, 7, 3.265306, -0.087787},
    { 182.86, 16000000, 14, 320, 2, 7, 3.265306, -0.087787},
    { 209.00, 16000000, 8, 209, 2, 8, 3.265625, -0.087698},
    { 209.00, 16000000, 16, 418, 2, 8, 3.265625, -0.087698},
    { 182.93, 16000000, 15, 343, 2, 7, 3.266667, -0.087407},
    { 209.07, 16000000, 15, 392, 2, 8, 3.266667, -0.087407},
    { 183.00, 16000000, 8, 183, 2, 7, 3.267857, -0.087075},
    { 183.00, 16000000, 16, 366, 2, 7, 3.267857, -0.087075},
    { 209.14, 16000000, 7, 183, 2, 8, 3.267857, -0.087075},
    { 209.14, 16000000, 14, 366, 2, 8, 3.267857, -0.087075},
    { 183.06, 16000000, 17, 389, 2, 7, 3.268908, -0.086781},
    { 209.23, 16000000, 13, 340, 2, 8, 3.269231, -0.086691},
    { 183.11, 16000000, 9, 206, 2, 7, 3.269841, -0.086520},
    { 183.11, 16000000, 18, 412, 2, 7, 3.269841, -0.086520},
    { 209.33, 16000000, 6, 157, 2, 8, 3.270833, -0.086243},
    { 209.33, 16000000, 12, 314, 2, 8, 3.270833, -0.086243},
    { 183.20, 16000000, 10, 229, 2, 7, 3.271429, -0.086077},
    { 183.27, 16000000, 11, 252, 2, 7, 3.272727, -0.085714},
    { 209.45, 16000000, 11, 288, 2, 8, 3.272727, -0.085714},
    { 209.50, 16000000, 16, 419, 2, 8, 3.273438, -0.085516},
    { 183.33, 16000000, 12, 275, 2, 7, 3.273810, -0.085412},
    { 183.38, 16000000, 13, 298, 2, 7, 3.274725, -0.085156},
    { 209.60, 16000000, 5, 131, 2, 8, 3.275000, -0.085079},
    { 209.60, 16000000, 10, 262, 2, 8, 3.275000, -0.085079},
    { 209.60, 16000000, 15, 393, 2, 8, 3.275000, -0.085079},
    { 183.43, 16000000, 14, 321, 2, 7, 3.275510, -0.084937},
    { 183.47, 16000000, 15, 344, 2, 7, 3.276190, -0.084747},
    { 183.50, 16000000, 16, 367, 2, 7, 3.276786, -0.084580},
    { 209.71, 16000000, 14, 367, 2, 8, 3.276786, -0.084580},
    { 183.53, 16000000, 17, 390, 2, 7, 3.277311, -0.084434},
    { 209.78, 16000000, 9, 236, 2, 8, 3.277778, -0.084303},
    { 183.56, 16000000, 18, 413, 2, 7, 3.277778, -0.084303},
    { 209.85, 16000000, 13, 341, 2, 8, 3.278846, -0.084005},
    { 210.00, 16000000, 4, 105, 2, 8, 3.281250, -0.083333},
    { 210.00, 16000000, 8, 210, 2, 8, 3.281250, -0.083333},
    { 210.00, 16000000, 12, 315, 2, 8, 3.281250, -0.083333},
    { 210.00, 16000000, 16, 420, 2, 8, 3.281250, -0.083333},
    { 210.13, 16000000, 15, 394, 2, 8, 3.283333, -0.082751},
    { 210.18, 16000000, 11, 289, 2, 8, 3.284091, -0.082540},
    { 184.00, 16000000, 3, 69, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 4, 92, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 5, 115, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 6, 138, 2, 7, 3.285714, -0.082086},
    { 210.29, 16000000, 7, 184, 2, 8, 3.285714, -0.082086},
    { 184.00, 16000000, 8, 184, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 9, 207, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 10, 230, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 11, 253, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 12, 276, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 13, 299, 2, 7, 3.285714, -0.082086},
    { 210.29, 16000000, 14, 368, 2, 8, 3.285714, -0.082086},
    { 184.00, 16000000, 15, 345, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 16, 368, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 17, 391, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 18, 414, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 7, 161, 2, 7, 3.285714, -0.082086},
    { 184.00, 16000000, 14, 322, 2, 7, 3.285714, -0.082086},
    { 210.40, 16000000, 10, 263, 2, 8, 3.287500, -0.081587},
    { 210.46, 16000000, 13, 342, 2, 8, 3.288462, -0.081319},
    { 210.50, 16000000, 16, 421, 2, 8, 3.289062, -0.081151},
    { 210.67, 16000000, 3, 79, 2, 8, 3.291667, -0.080423},
    { 210.67, 16000000, 6, 158, 2, 8, 3.291667, -0.080423},
    { 210.67, 16000000, 9, 237, 2, 8, 3.291667, -0.080423},
    { 210.67, 16000000, 12, 316, 2, 8, 3.291667, -0.080423},
    { 210.67, 16000000, 15, 395, 2, 8, 3.291667, -0.080423},
    { 184.44, 16000000, 18, 415, 2, 7, 3.293651, -0.079869},
    { 184.47, 16000000, 17, 392, 2, 7, 3.294118, -0.079738},
    { 210.86, 16000000, 14, 369, 2, 8, 3.294643, -0.079592},
    { 184.50, 16000000, 16, 369, 2, 7, 3.294643, -0.079592},
    { 184.53, 16000000, 15, 346, 2, 7, 3.295238, -0.079425},
    { 210.91, 16000000, 11, 290, 2, 8, 3.295455, -0.079365},
    { 184.57, 16000000, 14, 323, 2, 7, 3.295918, -0.079235},
    { 184.62, 16000000, 13, 300, 2, 7, 3.296703, -0.079016},
    { 211.00, 16000000, 8, 211, 2, 8, 3.296875, -0.078968},
    { 211.00, 16000000, 16, 422, 2, 8, 3.296875, -0.078968},
    { 184.67, 16000000, 12, 277, 2, 7, 3.297619, -0.078760},
    { 211.08, 16000000, 13, 343, 2, 8, 3.298077, -0.078632},
    { 184.73, 16000000, 11, 254, 2, 7, 3.298701, -0.078458},
    { 211.20, 16000000, 5, 132, 2, 8, 3.300000, -0.078095},
    { 184.80, 16000000, 10, 231, 2, 7, 3.300000, -0.078095},
    { 211.20, 16000000, 10, 264, 2, 8, 3.300000, -0.078095},
    { 211.20, 16000000, 15, 396, 2, 8, 3.300000, -0.078095},
    { 184.89, 16000000, 9, 208, 2, 7, 3.301587, -0.077652},
    { 184.89, 16000000, 18, 416, 2, 7, 3.301587, -0.077652},
    { 211.33, 16000000, 12, 317, 2, 8, 3.302083, -0.077513},
    { 184.94, 16000000, 17, 393, 2, 7, 3.302521, -0.077391},
    { 211.43, 16000000, 7, 185, 2, 8, 3.303571, -0.077097},
    { 185.00, 16000000, 8, 185, 2, 7, 3.303571, -0.077097},
    { 211.43, 16000000, 14, 370, 2, 8, 3.303571, -0.077097},
    { 185.00, 16000000, 16, 370, 2, 7, 3.303571, -0.077097},
    { 211.50, 16000000, 16, 423, 2, 8, 3.304688, -0.076786},
    { 185.07, 16000000, 15, 347, 2, 7, 3.304762, -0.076765},
    { 211.56, 16000000, 9, 238, 2, 8, 3.305556, -0.076543},
    { 185.14, 16000000, 7, 162, 2, 7, 3.306122, -0.076385},
    { 185.14, 16000000, 14, 324, 2, 7, 3.306122, -0.076385},
    { 211.64, 16000000, 11, 291, 2, 8, 3.306818, -0.076190},
    { 185.23, 16000000, 13, 301, 2, 7, 3.307692, -0.075946},
    { 211.69, 16000000, 13, 344, 2, 8, 3.307692, -0.075946},
    { 211.73, 16000000, 15, 397, 2, 8, 3.308333, -0.075767},
    { 185.33, 16000000, 6, 139, 2, 7, 3.309524, -0.075435},
    { 185.33, 16000000, 12, 278, 2, 7, 3.309524, -0.075435},
    { 185.33, 16000000, 18, 417, 2, 7, 3.309524, -0.075435},
    { 185.41, 16000000, 17, 394, 2, 7, 3.310924, -0.075043},
    { 185.45, 16000000, 11, 255, 2, 7, 3.311688, -0.074830},
    { 212.00, 16000000, 2, 53, 2, 8, 3.312500, -0.074603},
    { 212.00, 16000000, 4, 106, 2, 8, 3.312500, -0.074603},
    { 212.00, 16000000, 6, 159, 2, 8, 3.312500, -0.074603},
    { 212.00, 16000000, 8, 212, 2, 8, 3.312500, -0.074603},
    { 212.00, 16000000, 10, 265, 2, 8, 3.312500, -0.074603},
    { 212.00, 16000000, 12, 318, 2, 8, 3.312500, -0.074603},
    { 185.50, 16000000, 16, 371, 2, 7, 3.312500, -0.074603},
    { 212.00, 16000000, 16, 424, 2, 8, 3.312500, -0.074603},
    { 212.00, 16000000, 14, 371, 2, 8, 3.312500, -0.074603},
    { 185.60, 16000000, 5, 116, 2, 7, 3.314286, -0.074104},
    { 185.60, 16000000, 10, 232, 2, 7, 3.314286, -0.074104},
    { 185.60, 16000000, 15, 348, 2, 7, 3.314286, -0.074104},
    { 185.71, 16000000, 14, 325, 2, 7, 3.316327, -0.073534},
    { 212.27, 16000000, 15, 398, 2, 8, 3.316667, -0.073439},
    { 212.31, 16000000, 13, 345, 2, 8, 3.317308, -0.073260},
    { 185.78, 16000000, 9, 209, 2, 7, 3.317460, -0.073217},
    { 185.78, 16000000, 18, 418, 2, 7, 3.317460, -0.073217},
    { 212.36, 16000000, 11, 292, 2, 8, 3.318182, -0.073016},
    { 185.85, 16000000, 13, 302, 2, 7, 3.318681, -0.072876},
    { 185.88, 16000000, 17, 395, 2, 7, 3.319328, -0.072696},
    { 212.44, 16000000, 9, 239, 2, 8, 3.319444, -0.072663},
    { 212.50, 16000000, 16, 425, 2, 8, 3.320312, -0.072421},
    { 186.00, 16000000, 4, 93, 2, 7, 3.321429, -0.072109},
    { 186.00, 16000000, 8, 186, 2, 7, 3.321429, -0.072109},
    { 186.00, 16000000, 12, 279, 2, 7, 3.321429, -0.072109},
    { 186.00, 16000000, 16, 372, 2, 7, 3.321429, -0.072109},
    { 212.57, 16000000, 7, 186, 2, 8, 3.321429, -0.072109},
    { 212.57, 16000000, 14, 372, 2, 8, 3.321429, -0.072109},
    { 212.67, 16000000, 12, 319, 2, 8, 3.322917, -0.071693},
    { 186.13, 16000000, 15, 349, 2, 7, 3.323810, -0.071444},
    { 186.18, 16000000, 11, 256, 2, 7, 3.324675, -0.071202},
    { 212.80, 16000000, 5, 133, 2, 8, 3.325000, -0.071111},
    { 212.80, 16000000, 10, 266, 2, 8, 3.325000, -0.071111},
    { 212.80, 16000000, 15, 399, 2, 8, 3.325000, -0.071111},
    { 186.22, 16000000, 18, 419, 2, 7, 3.325397, -0.071000},
    { 186.29, 16000000, 7, 163, 2, 7, 3.326531, -0.070683},
    { 186.29, 16000000, 14, 326, 2, 7, 3.326531, -0.070683},
    { 212.92, 16000000, 13, 346, 2, 8, 3.326923, -0.070574},
    { 186.35, 16000000, 17, 396, 2, 7, 3.327731, -0.070348},
    { 213.00, 16000000, 8, 213, 2, 8, 3.328125, -0.070238},
    { 213.00, 16000000, 16, 426, 2, 8, 3.328125, -0.070238},
    { 186.40, 16000000, 10, 233, 2, 7, 3.328571, -0.070113},
    { 213.09, 16000000, 11, 293, 2, 8, 3.329545, -0.069841},
    { 186.46, 16000000, 13, 303, 2, 7, 3.329670, -0.069806},
    { 186.50, 16000000, 16, 373, 2, 7, 3.330357, -0.069614},
    { 213.14, 16000000, 14, 373, 2, 8, 3.330357, -0.069614},
    { 186.67, 16000000, 3, 70, 2, 7, 3.333333, -0.068783},
    { 213.33, 16000000, 3, 80, 2, 8, 3.333333, -0.068783},
    { 186.67, 16000000, 6, 140, 2, 7, 3.333333, -0.068783},
    { 213.33, 16000000, 6, 160, 2, 8, 3.333333, -0.068783},
    { 186.67, 16000000, 9, 210, 2, 7, 3.333333, -0.068783},
    { 186.67, 16000000, 12, 280, 2, 7, 3.333333, -0.068783},
    { 213.33, 16000000, 12, 320, 2, 8, 3.333333, -0.068783},
    { 186.67, 16000000, 18, 420, 2, 7, 3.333333, -0.068783},
    { 213.33, 16000000, 9, 240, 2, 8, 3.333333, -0.068783},
    { 186.67, 16000000, 15, 350, 2, 7, 3.333333, -0.068783},
    { 213.33, 16000000, 15, 400, 2, 8, 3.333333, -0.068783},
    { 213.50, 16000000, 16, 427, 2, 8, 3.335938, -0.068055},
    { 186.82, 16000000, 17, 397, 2, 7, 3.336134, -0.068000},
    { 213.54, 16000000, 13, 347, 2, 8, 3.336538, -0.067888},
    { 186.86, 16000000, 14, 327, 2, 7, 3.336735, -0.067833},
    { 213.60, 16000000, 10, 267, 2, 8, 3.337500, -0.067619},
    { 186.91, 16000000, 11, 257, 2, 7, 3.337662, -0.067574},
    { 187.00, 16000000, 8, 187, 2, 7, 3.339286, -0.067120},
    { 187.00, 16000000, 16, 374, 2, 7, 3.339286, -0.067120},
    { 213.71, 16000000, 7, 187, 2, 8, 3.339286, -0.067120},
    { 213.71, 16000000, 14, 374, 2, 8, 3.339286, -0.067120},
    { 187.08, 16000000, 13, 304, 2, 7, 3.340659, -0.066736},
    { 213.82, 16000000, 11, 294, 2, 8, 3.340909, -0.066667},
    { 187.11, 16000000, 18, 421, 2, 7, 3.341270, -0.066566},
    { 213.87, 16000000, 15, 401, 2, 8, 3.341667, -0.066455},
    { 187.20, 16000000, 5, 117, 2, 7, 3.342857, -0.066122},
    { 187.20, 16000000, 10, 234, 2, 7, 3.342857, -0.066122},
    { 187.20, 16000000, 15, 351, 2, 7, 3.342857, -0.066122},
    { 214.00, 16000000, 4, 107, 2, 8, 3.343750, -0.065873},
    { 214.00, 16000000, 8, 214, 2, 8, 3.343750, -0.065873},
    { 214.00, 16000000, 12, 321, 2, 8, 3.343750, -0.065873},
    { 214.00, 16000000, 16, 428, 2, 8, 3.343750, -0.065873},
    { 187.29, 16000000, 17, 398, 2, 7, 3.344538, -0.065653},
    { 187.33, 16000000, 12, 281, 2, 7, 3.345238, -0.065457},
    { 214.15, 16000000, 13, 348, 2, 8, 3.346154, -0.065201},
    { 187.43, 16000000, 7, 164, 2, 7, 3.346939, -0.064982},
    { 187.43, 16000000, 14, 328, 2, 7, 3.346939, -0.064982},
    { 214.22, 16000000, 9, 241, 2, 8, 3.347222, -0.064903},
    { 214.29, 16000000, 14, 375, 2, 8, 3.348214, -0.064626},
    { 187.50, 16000000, 16, 375, 2, 7, 3.348214, -0.064626},
    { 187.56, 16000000, 9, 211, 2, 7, 3.349206, -0.064349},
    { 187.56, 16000000, 18, 422, 2, 7, 3.349206, -0.064349},
    { 214.40, 16000000, 5, 134, 2, 8, 3.350000, -0.064127},
    { 214.40, 16000000, 10, 268, 2, 8, 3.350000, -0.064127},
    { 214.40, 16000000, 15, 402, 2, 8, 3.350000, -0.064127},
    { 187.64, 16000000, 11, 258, 2, 7, 3.350649, -0.063945},
    { 214.50, 16000000, 16, 429, 2, 8, 3.351562, -0.063690},
    { 187.69, 16000000, 13, 305, 2, 7, 3.351648, -0.063666},
    { 214.55, 16000000, 11, 295, 2, 8, 3.352273, -0.063492},
    { 187.73, 16000000, 15, 352, 2, 7, 3.352381, -0.063462},
    { 187.76, 16000000, 17, 399, 2, 7, 3.352941, -0.063305},
    { 214.67, 16000000, 6, 161, 2, 8, 3.354167, -0.062963},
    { 214.67, 16000000, 12, 322, 2, 8, 3.354167, -0.062963},
    { 214.77, 16000000, 13, 349, 2, 8, 3.355769, -0.062515},
    { 188.00, 16000000, 4, 94, 2, 7, 3.357143, -0.062131},
    { 188.00, 16000000, 6, 141, 2, 7, 3.357143, -0.062131},
    { 214.86, 16000000, 7, 188, 2, 8, 3.357143, -0.062131},
    { 188.00, 16000000, 8, 188, 2, 7, 3.357143, -0.062131},
    { 188.00, 16000000, 10, 235, 2, 7, 3.357143, -0.062131},
    { 188.00, 16000000, 12, 282, 2, 7, 3.357143, -0.062131},
    { 214.86, 16000000, 14, 376, 2, 8, 3.357143, -0.062131},
    { 188.00, 16000000, 16, 376, 2, 7, 3.357143, -0.062131},
    { 188.00, 16000000, 18, 423, 2, 7, 3.357143, -0.062131},
    { 188.00, 16000000, 14, 329, 2, 7, 3.357143, -0.062131},
    { 214.93, 16000000, 15, 403, 2, 8, 3.358333, -0.061799},
    { 215.00, 16000000, 8, 215, 2, 8, 3.359375, -0.061508},
    { 215.00, 16000000, 16, 430, 2, 8, 3.359375, -0.061508},
    { 215.11, 16000000, 9, 242, 2, 8, 3.361111, -0.061023},
    { 188.24, 16000000, 17, 400, 2, 7, 3.361345, -0.060958},
    { 188.27, 16000000, 15, 353, 2, 7, 3.361905, -0.060801},
    { 215.20, 16000000, 10, 269, 2, 8, 3.362500, -0.060635},
    { 188.31, 16000000, 13, 306, 2, 7, 3.362637, -0.060596},
    { 188.36, 16000000, 11, 259, 2, 7, 3.363636, -0.060317},
    { 215.27, 16000000, 11, 296, 2, 8, 3.363636, -0.060317},
    { 215.33, 16000000, 12, 323, 2, 8, 3.364583, -0.060053},
    { 188.44, 16000000, 9, 212, 2, 7, 3.365079, -0.059914},
    { 188.44, 16000000, 18, 424, 2, 7, 3.365079, -0.059914},
    { 215.38, 16000000, 13, 350, 2, 8, 3.365385, -0.059829},
    { 215.43, 16000000, 14, 377, 2, 8, 3.366071, -0.059637},
    { 188.50, 16000000, 16, 377, 2, 7, 3.366071, -0.059637},
    { 215.47, 16000000, 15, 404, 2, 8, 3.366667, -0.059471},
    { 215.50, 16000000, 16, 431, 2, 8, 3.367188, -0.059325},
    { 188.57, 16000000, 7, 165, 2, 7, 3.367347, -0.059281},
    { 188.57, 16000000, 14, 330, 2, 7, 3.367347, -0.059281},
    { 188.67, 16000000, 12, 283, 2, 7, 3.369048, -0.058806},
    { 188.71, 16000000, 17, 401, 2, 7, 3.369748, -0.058610},
    { 188.80, 16000000, 5, 118, 2, 7, 3.371429, -0.058140},
    { 188.80, 16000000, 10, 236, 2, 7, 3.371429, -0.058140},
    { 188.80, 16000000, 15, 354, 2, 7, 3.371429, -0.058140},
    { 188.89, 16000000, 18, 425, 2, 7, 3.373016, -0.057697},
    { 188.92, 16000000, 13, 307, 2, 7, 3.373626, -0.057526},
    { 216.00, 16000000, 2, 54, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 3, 81, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 4, 108, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 5, 135, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 6, 162, 2, 8, 3.375000, -0.057143},
    { 189.00, 16000000, 8, 189, 2, 7, 3.375000, -0.057143},
    { 216.00, 16000000, 8, 216, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 9, 243, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 10, 270, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 11, 297, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 12, 324, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 13, 351, 2, 8, 3.375000, -0.057143},
    { 189.00, 16000000, 16, 378, 2, 7, 3.375000, -0.057143},
    { 216.00, 16000000, 7, 189, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 14, 378, 2, 8, 3.375000, -0.057143},
    { 216.00, 16000000, 15, 405, 2, 8, 3.375000, -0.057143},
    { 189.09, 16000000, 11, 260, 2, 7, 3.376623, -0.056689},
    { 189.14, 16000000, 14, 331, 2, 7, 3.377551, -0.056430},
    { 189.18, 16000000, 17, 402, 2, 7, 3.378151, -0.056262},
    { 189.33, 16000000, 3, 71, 2, 7, 3.380952, -0.055480},
    { 189.33, 16000000, 6, 142, 2, 7, 3.380952, -0.055480},
    { 189.33, 16000000, 12, 284, 2, 7, 3.380952, -0.055480},
    { 189.33, 16000000, 9, 213, 2, 7, 3.380952, -0.055480},
    { 189.33, 16000000, 15, 355, 2, 7, 3.380952, -0.055480},
    { 189.33, 16000000, 18, 426, 2, 7, 3.380952, -0.055480},
    { 216.53, 16000000, 15, 406, 2, 8, 3.383333, -0.054815},
    { 189.50, 16000000, 16, 379, 2, 7, 3.383929, -0.054648},
    { 216.57, 16000000, 14, 379, 2, 8, 3.383929, -0.054648},
    { 189.54, 16000000, 13, 308, 2, 7, 3.384615, -0.054457},
    { 216.62, 16000000, 13, 352, 2, 8, 3.384615, -0.054457},
    { 216.67, 16000000, 12, 325, 2, 8, 3.385417, -0.054233},
    { 189.60, 16000000, 10, 237, 2, 7, 3.385714, -0.054150},
    { 216.73, 16000000, 11, 298, 2, 8, 3.386364, -0.053968},
    { 189.65, 16000000, 17, 403, 2, 7, 3.386555, -0.053915},
    { 216.80, 16000000, 10, 271, 2, 8, 3.387500, -0.053651},
    { 189.71, 16000000, 7, 166, 2, 7, 3.387755, -0.053579},
    { 189.71, 16000000, 14, 332, 2, 7, 3.387755, -0.053579},
    { 189.78, 16000000, 18, 427, 2, 7, 3.388889, -0.053263},
    { 216.89, 16000000, 9, 244, 2, 8, 3.388889, -0.053263},
    { 189.82, 16000000, 11, 261, 2, 7, 3.389610, -0.053061},
    { 189.87, 16000000, 15, 356, 2, 7, 3.390476, -0.052819},
    { 217.00, 16000000, 8, 217, 2, 8, 3.390625, -0.052778},
    { 217.07, 16000000, 15, 407, 2, 8, 3.391667, -0.052487},
    { 190.00, 16000000, 4, 95, 2, 7, 3.392857, -0.052154},
    { 190.00, 16000000, 8, 190, 2, 7, 3.392857, -0.052154},
    { 190.00, 16000000, 12, 285, 2, 7, 3.392857, -0.052154},
    { 190.00, 16000000, 16, 380, 2, 7, 3.392857, -0.052154},
    { 217.14, 16000000, 7, 190, 2, 8, 3.392857, -0.052154},
    { 217.14, 16000000, 14, 380, 2, 8, 3.392857, -0.052154},
    { 217.23, 16000000, 13, 353, 2, 8, 3.394231, -0.051770},
    { 190.12, 16000000, 17, 404, 2, 7, 3.394958, -0.051567},
    { 190.15, 16000000, 13, 309, 2, 7, 3.395604, -0.051387},
    { 217.33, 16000000, 6, 163, 2, 8, 3.395833, -0.051323},
    { 217.33, 16000000, 12, 326, 2, 8, 3.395833, -0.051323},
    { 190.22, 16000000, 9, 214, 2, 7, 3.396825, -0.051045},
    { 190.22, 16000000, 18, 428, 2, 7, 3.396825, -0.051045},
    { 217.45, 16000000, 11, 299, 2, 8, 3.397727, -0.050794},
    { 190.29, 16000000, 14, 333, 2, 7, 3.397959, -0.050729},
    { 190.40, 16000000, 5, 119, 2, 7, 3.400000, -0.050159},
    { 217.60, 16000000, 5, 136, 2, 8, 3.400000, -0.050159},
    { 190.40, 16000000, 10, 238, 2, 7, 3.400000, -0.050159},
    { 217.60, 16000000, 10, 272, 2, 8, 3.400000, -0.050159},
    { 190.40, 16000000, 15, 357, 2, 7, 3.400000, -0.050159},
    { 217.60, 16000000, 15, 408, 2, 8, 3.400000, -0.050159},
    { 190.50, 16000000, 16, 381, 2, 7, 3.401786, -0.049660},
    { 217.71, 16000000, 14, 381, 2, 8, 3.401786, -0.049660},
    { 190.55, 16000000, 11, 262, 2, 7, 3.402597, -0.049433},
    { 217.78, 16000000, 9, 245, 2, 8, 3.402778, -0.049383},
    { 190.59, 16000000, 17, 405, 2, 7, 3.403361, -0.049220},
    { 217.85, 16000000, 13, 354, 2, 8, 3.403846, -0.049084},
    { 190.67, 16000000, 6, 143, 2, 7, 3.404762, -0.048828},
    { 190.67, 16000000, 12, 286, 2, 7, 3.404762, -0.048828},
    { 190.67, 16000000, 18, 429, 2, 7, 3.404762, -0.048828},
    { 218.00, 16000000, 4, 109, 2, 8, 3.406250, -0.048413},
    { 218.00, 16000000, 8, 218, 2, 8, 3.406250, -0.048413},
    { 218.00, 16000000, 12, 327, 2, 8, 3.406250, -0.048413},
    { 190.77, 16000000, 13, 310, 2, 7, 3.406593, -0.048317},
    { 190.86, 16000000, 7, 167, 2, 7, 3.408163, -0.047878},
    { 190.86, 16000000, 14, 334, 2, 7, 3.408163, -0.047878},
    { 218.13, 16000000, 15, 409, 2, 8, 3.408333, -0.047831},
    { 218.18, 16000000, 11, 300, 2, 8, 3.409091, -0.047619},
    { 190.93, 16000000, 15, 358, 2, 7, 3.409524, -0.047498},
    { 218.29, 16000000, 7, 191, 2, 8, 3.410714, -0.047165},
    { 191.00, 16000000, 8, 191, 2, 7, 3.410714, -0.047165},
    { 218.29, 16000000, 14, 382, 2, 8, 3.410714, -0.047165},
    { 191.00, 16000000, 16, 382, 2, 7, 3.410714, -0.047165},
    { 191.06, 16000000, 17, 406, 2, 7, 3.411765, -0.046872},
    { 218.40, 16000000, 10, 273, 2, 8, 3.412500, -0.046667},
    { 191.11, 16000000, 9, 215, 2, 7, 3.412698, -0.046611},
    { 191.11, 16000000, 18, 430, 2, 7, 3.412698, -0.046611},
    { 218.46, 16000000, 13, 355, 2, 8, 3.413462, -0.046398},
    { 191.20, 16000000, 10, 239, 2, 7, 3.414286, -0.046168},
    { 191.27, 16000000, 11, 263, 2, 7, 3.415584, -0.045805},
    { 218.67, 16000000, 3, 82, 2, 8, 3.416667, -0.045503},
    { 218.67, 16000000, 6, 164, 2, 8, 3.416667, -0.045503},
    { 218.67, 16000000, 9, 246, 2, 8, 3.416667, -0.045503},
    { 191.33, 16000000, 12, 287, 2, 7, 3.416667, -0.045503},
    { 218.67, 16000000, 12, 328, 2, 8, 3.416667, -0.045503},
    { 218.67, 16000000, 15, 410, 2, 8, 3.416667, -0.045503},
    { 191.38, 16000000, 13, 311, 2, 7, 3.417582, -0.045247},
    { 191.43, 16000000, 14, 335, 2, 7, 3.418367, -0.045027},
    { 191.47, 16000000, 15, 359, 2, 7, 3.419048, -0.044837},
    { 218.86, 16000000, 14, 383, 2, 8, 3.419643, -0.044671},
    { 191.50, 16000000, 16, 383, 2, 7, 3.419643, -0.044671},
    { 191.53, 16000000, 17, 407, 2, 7, 3.420168, -0.044524},
    { 218.91, 16000000, 11, 301, 2, 8, 3.420455, -0.044444},
    { 191.56, 16000000, 18, 431, 2, 7, 3.420635, -0.044394},
    { 219.00, 16000000, 8, 219, 2, 8, 3.421875, -0.044047},
    { 219.08, 16000000, 13, 356, 2, 8, 3.423077, -0.043712},
    { 219.20, 16000000, 5, 137, 2, 8, 3.425000, -0.043174},
    { 219.20, 16000000, 10, 274, 2, 8, 3.425000, -0.043174},
    { 219.20, 16000000, 15, 411, 2, 8, 3.425000, -0.043174},
    { 219.33, 16000000, 12, 329, 2, 8, 3.427083, -0.042592},
    { 192.00, 16000000, 3, 72, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 4, 96, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 5, 120, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 6, 144, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 8, 192, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 9, 216, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 10, 240, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 11, 264, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 12, 288, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 13, 312, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 15, 360, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 16, 384, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 17, 408, 2, 7, 3.428571, -0.042177},
    { 192.00, 16000000, 7, 168, 2, 7, 3.428571, -0.042177},
    { 219.43, 16000000, 7, 192, 2, 8, 3.428571, -0.042177},
    { 192.00, 16000000, 14, 336, 2, 7, 3.428571, -0.042177},
    { 219.43, 16000000, 14, 384, 2, 8, 3.428571, -0.042177},
    { 219.56, 16000000, 9, 247, 2, 8, 3.430556, -0.041622},
    { 219.64, 16000000, 11, 302, 2, 8, 3.431818, -0.041270},
    { 219.69, 16000000, 13, 357, 2, 8, 3.432692, -0.041026},
    { 219.73, 16000000, 15, 412, 2, 8, 3.433333, -0.040846},
    { 192.47, 16000000, 17, 409, 2, 7, 3.436975, -0.039829},
    { 192.50, 16000000, 16, 385, 2, 7, 3.437500, -0.039682},
    { 192.53, 16000000, 15, 361, 2, 7, 3.438095, -0.039516},
    { 192.57, 16000000, 14, 337, 2, 7, 3.438776, -0.039326},
    { 192.62, 16000000, 13, 313, 2, 7, 3.439560, -0.039107},
    { 192.67, 16000000, 12, 289, 2, 7, 3.440476, -0.038851},
    { 192.73, 16000000, 11, 265, 2, 7, 3.441558, -0.038549},
    { 192.80, 16000000, 10, 241, 2, 7, 3.442857, -0.038186},
    { 192.89, 16000000, 9, 217, 2, 7, 3.444444, -0.037742},
    { 192.94, 16000000, 17, 410, 2, 7, 3.445378, -0.037482},
    { 193.00, 16000000, 8, 193, 2, 7, 3.446429, -0.037188},
    { 193.00, 16000000, 16, 386, 2, 7, 3.446429, -0.037188},
    { 193.07, 16000000, 15, 362, 2, 7, 3.447619, -0.036856},
    { 193.14, 16000000, 7, 169, 2, 7, 3.448980, -0.036475},
    { 193.14, 16000000, 14, 338, 2, 7, 3.448980, -0.036475},
    { 193.23, 16000000, 13, 314, 2, 7, 3.450549, -0.036037},
    { 193.33, 16000000, 6, 145, 2, 7, 3.452381, -0.035525},
    { 193.33, 16000000, 12, 290, 2, 7, 3.452381, -0.035525},
    { 193.41, 16000000, 17, 411, 2, 7, 3.453782, -0.035134},
    { 193.45, 16000000, 11, 266, 2, 7, 3.454545, -0.034921},
    { 193.50, 16000000, 16, 387, 2, 7, 3.455357, -0.034694},
    { 193.60, 16000000, 5, 121, 2, 7, 3.457143, -0.034195},
    { 193.60, 16000000, 10, 242, 2, 7, 3.457143, -0.034195},
    { 193.60, 16000000, 15, 363, 2, 7, 3.457143, -0.034195},
    { 193.71, 16000000, 14, 339, 2, 7, 3.459184, -0.033625},
    { 193.78, 16000000, 9, 218, 2, 7, 3.460317, -0.033308},
    { 193.85, 16000000, 13, 315, 2, 7, 3.461538, -0.032967},
    { 193.88, 16000000, 17, 412, 2, 7, 3.462185, -0.032786},
    { 194.00, 16000000, 4, 97, 2, 7, 3.464286, -0.032199},
    { 194.00, 16000000, 8, 194, 2, 7, 3.464286, -0.032199},
    { 194.00, 16000000, 12, 291, 2, 7, 3.464286, -0.032199},
    { 194.00, 16000000, 16, 388, 2, 7, 3.464286, -0.032199},
    { 194.13, 16000000, 15, 364, 2, 7, 3.466667, -0.031534},
    { 194.18, 16000000, 11, 267, 2, 7, 3.467532, -0.031292},
    { 194.29, 16000000, 7, 170, 2, 7, 3.469388, -0.030774},
    { 194.29, 16000000, 14, 340, 2, 7, 3.469388, -0.030774},
    { 194.35, 16000000, 17, 413, 2, 7, 3.470588, -0.030439},
    { 194.40, 16000000, 10, 243, 2, 7, 3.471429, -0.030204},
    { 194.46, 16000000, 13, 316, 2, 7, 3.472527, -0.029897},
    { 194.50, 16000000, 16, 389, 2, 7, 3.473214, -0.029705},
    { 194.67, 16000000, 3, 73, 2, 7, 3.476190, -0.028874},
    { 194.67, 16000000, 6, 146, 2, 7, 3.476190, -0.028874},
    { 194.67, 16000000, 9, 219, 2, 7, 3.476190, -0.028874},
    { 194.67, 16000000, 12, 292, 2, 7, 3.476190, -0.028874},
    { 194.67, 16000000, 15, 365, 2, 7, 3.476190, -0.028874},
    { 194.82, 16000000, 17, 414, 2, 7, 3.478992, -0.028091},
    { 194.86, 16000000, 14, 341, 2, 7, 3.479592, -0.027923},
    { 194.91, 16000000, 11, 268, 2, 7, 3.480519, -0.027664},
    { 195.00, 16000000, 8, 195, 2, 7, 3.482143, -0.027211},
    { 195.00, 16000000, 16, 390, 2, 7, 3.482143, -0.027211},
    { 195.08, 16000000, 13, 317, 2, 7, 3.483516, -0.026827},
    { 195.20, 16000000, 5, 122, 2, 7, 3.485714, -0.026213},
    { 195.20, 16000000, 10, 244, 2, 7, 3.485714, -0.026213},
    { 195.20, 16000000, 15, 366, 2, 7, 3.485714, -0.026213},
    { 195.29, 16000000, 17, 415, 2, 7, 3.487395, -0.025744},
    { 195.33, 16000000, 12, 293, 2, 7, 3.488095, -0.025548},
    { 195.43, 16000000, 7, 171, 2, 7, 3.489796, -0.025073},
    { 195.43, 16000000, 14, 342, 2, 7, 3.489796, -0.025073},
    { 195.50, 16000000, 16, 391, 2, 7, 3.491071, -0.024716},
    { 195.56, 16000000, 9, 220, 2, 7, 3.492063, -0.024439},
    { 195.64, 16000000, 11, 269, 2, 7, 3.493506, -0.024036},

#if 0
    {157.50, 16000000, 16, 315, 2, 11, 3.579545, 0.000000},
    {114.55, 16000000, 22, 315, 2, 8, 3.579545, 0.000000},
    {186.13, 16000000, 15, 349, 2, 13, 3.579487, -0.000016},
    {214.77, 16000000, 13, 349, 2, 15, 3.579487, -0.000016},
    {100.24, 16000000, 17, 213, 2, 7, 3.579832, 0.000080},
    {200.47, 16000000, 17, 426, 2, 14, 3.579832, 0.000080},
    {100.24, 16000000, 34, 426, 2, 7, 3.579832, 0.000080},
    {143.20, 16000000, 10, 179, 2, 10, 3.580000, 0.000127},
    {143.20, 16000000, 20, 358, 2, 10, 3.580000, 0.000127},
    {114.56, 16000000, 25, 358, 2, 8, 3.580000, 0.000127},
    {100.21, 16000000, 19, 238, 2, 7, 3.578947, -0.000167},
    {114.53, 16000000, 19, 272, 2, 8, 3.578947, -0.000167},
    {128.84, 16000000, 19, 306, 2, 9, 3.578947, -0.000167},
    {143.16, 16000000, 19, 340, 2, 10, 3.578947, -0.000167},
    {157.47, 16000000, 19, 374, 2, 11, 3.578947, -0.000167},
    {171.79, 16000000, 19, 408, 2, 12, 3.578947, -0.000167},
    {128.89, 16000000, 9, 145, 2, 9, 3.580247, 0.000196},
    {128.89, 16000000, 18, 290, 2, 9, 3.580247, 0.000196},
    {200.50, 16000000, 16, 401, 2, 14, 3.580357, 0.000227},
    {100.25, 16000000, 32, 401, 2, 7, 3.580357, 0.000227},
    {114.57, 16000000, 28, 401, 2, 8, 3.580357, 0.000227},
    {186.18, 16000000, 11, 256, 2, 13, 3.580420, 0.000244},
    {157.54, 16000000, 13, 256, 2, 11, 3.580420, 0.000244},
    {171.76, 16000000, 17, 365, 2, 12, 3.578431, -0.000311},
    {100.19, 16000000, 21, 263, 2, 7, 3.578231, -0.000367},
    {143.24, 16000000, 21, 376, 2, 10, 3.580952, 0.000393},
    {214.86, 16000000, 7, 188, 2, 15, 3.580952, 0.000393},
    {214.86, 16000000, 14, 376, 2, 15, 3.580952, 0.000393},
    {100.27, 16000000, 15, 188, 2, 7, 3.580952, 0.000393},
    {200.53, 16000000, 15, 376, 2, 14, 3.580952, 0.000393},
    {100.27, 16000000, 30, 376, 2, 7, 3.580952, 0.000393},
    {114.50, 16000000, 16, 229, 2, 8, 3.578125, -0.000397},
    {186.22, 16000000, 18, 419, 2, 13, 3.581197, 0.000461},
    {128.92, 16000000, 26, 419, 2, 9, 3.581197, 0.000461},
    {128.80, 16000000, 10, 161, 2, 9, 3.577778, -0.000494},
    {171.73, 16000000, 15, 322, 2, 12, 3.577778, -0.000494},
    {128.80, 16000000, 20, 322, 2, 9, 3.577778, -0.000494},
    {214.67, 16000000, 6, 161, 2, 15, 3.577778, -0.000494},
    {143.11, 16000000, 9, 161, 2, 10, 3.577778, -0.000494},
    {214.67, 16000000, 12, 322, 2, 15, 3.577778, -0.000494},
    {143.11, 16000000, 18, 322, 2, 10, 3.577778, -0.000494},
    {100.17, 16000000, 23, 288, 2, 7, 3.577640, -0.000532},
    {114.48, 16000000, 29, 415, 2, 8, 3.577586, -0.000547},
    {200.57, 16000000, 14, 351, 2, 14, 3.581633, 0.000583},
    {100.29, 16000000, 28, 351, 2, 7, 3.581633, 0.000583},
    {128.94, 16000000, 17, 274, 2, 9, 3.581699, 0.000602},
    {157.60, 16000000, 10, 197, 2, 11, 3.581818, 0.000635},
    {157.60, 16000000, 20, 394, 2, 11, 3.581818, 0.000635},
    {143.27, 16000000, 11, 197, 2, 10, 3.581818, 0.000635},
    {143.27, 16000000, 22, 394, 2, 10, 3.581818, 0.000635},
#endif
};
static const unsigned int clockConfigCount = sizeof(clockConfigs) / sizeof(clockConfigs[0]);

static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;

  /* Enable Power Control clock */
  __HAL_RCC_PWR_CLK_ENABLE();

  /* The voltage scaling allows optimizing the power consumption when the device is 
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);

  int PLL_M = clockConfigs[whichConfig].PLL_M;
  int PLL_N = clockConfigs[whichConfig].PLL_N;
  int PLL_P = clockConfigs[whichConfig].PLL_P;

#if 0

  unsigned int PLL_Q = (HSE_VALUE / PLL_M * PLL_N / PLL_P / 48 + 999999) / 1000000;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = PLL_M; // Divide HSE by this
  RCC_OscInitStruct.PLL.PLLN = PLL_N; // Then multiply by this 
  RCC_OscInitStruct.PLL.PLLP = PLL_P; // Then divide by this
  RCC_OscInitStruct.PLL.PLLQ = PLL_Q; // Divide by this for SD, USB OTG FS, and some other peripherals
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    panic();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; // APB1 clock
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV4; // APB2 clock
  // grantham - 5 cycles for 168MHz is stated in Table 10 in the STM32F4 reference manual
  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
  {
    panic();
  }

#else

  unsigned int PLL_Q = (HSI_VALUE / PLL_M * PLL_N / PLL_P / 48 + 999999) / 1000000;

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = PLL_M; // Divide high-speed clock by this
  RCC_OscInitStruct.PLL.PLLN = PLL_N; // Then multiply by this 
  RCC_OscInitStruct.PLL.PLLP = PLL_P; // Then divide by this
  RCC_OscInitStruct.PLL.PLLQ = PLL_Q; // Divide by this for SD, USB OTG FS, and some other peripherals
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    panic();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV8;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV4;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
  {
    panic();
  }

#endif

  /* Enable other CLKs */
  __HAL_RCC_TIM1_CLK_ENABLE();
  __HAL_RCC_TIM2_CLK_ENABLE();
  __HAL_RCC_TIM3_CLK_ENABLE();
  __HAL_RCC_TIM4_CLK_ENABLE();
  __HAL_RCC_TIM5_CLK_ENABLE();
  __HAL_RCC_TIM6_CLK_ENABLE();
  __HAL_RCC_TIM7_CLK_ENABLE();
  __HAL_RCC_TIM8_CLK_ENABLE();
  __HAL_RCC_TIM9_CLK_ENABLE();
  __HAL_RCC_DMA2_CLK_ENABLE();
  __HAL_RCC_DAC_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();

    // Since this relies solely on the clock 
    delay_init();
}

// Was in the 417's header but I could not find in the 746's headers
#ifndef RCC_PLLCFGR_RST_VALUE 
#define RCC_PLLCFGR_RST_VALUE 0x24003010
#endif

void DeInitRCCAndPLL()
{
    // Unset the RCC and reset it
    RCC->CR |= RCC_HSI_ON;
    RCC->CFGR = 0x00000000U;
    uint32_t vl_mask = 0xFFFFFFFFU;
    /* Reset HSEON, PLLSYSON bits */
    CLEAR_BIT(vl_mask, (RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_PLLON | RCC_CR_CSSON));
    RCC->CR &= vl_mask;
    RCC->CR = (RCC->CR & ~RCC_CR_HSITRIM_Msk) | (0x10 << RCC_CR_HSITRIM_Pos); /* Set HSITRIM bits to the reset value*/
    RCC->PLLCFGR = RCC_PLLCFGR_RST_VALUE; /* Reset PLLCFGR register */
    RCC->CR &= ~RCC_CR_HSEBYP; /* Reset HSEBYP bit */
  /* Disable all interrupts */
    RCC->CIR = 0x00000000U;
// *            - HSI ON and used as system clock source
// *            - HSE and PLL OFF
// *            - AHB, APB1 and APB2 prescaler set to 1.
// *            - CSS, MCO1 and MCO2 OFF
// *            - All interrupts disabled
}

//----------------------------------------------------------------------------
// stdio

#define OUTPUT_TO_SERIAL        0x01
#define OUTPUT_TO_TEXTPORT         0x02

int gOutputDevices = OUTPUT_TO_SERIAL;

// Assumed to be raw mode - returns next character, not buffering until newline
int __io_getchar(void)
{
    while(1) {
#ifdef USE_PS2KBD
        int c = KBD_process_queue(gDumpKeyboardData);
        if(c >= 0) {
            return c;
        }
#endif
        SERIAL_poll_continue();
        unsigned char isEmpty = queue_isempty(&mon_queue.q);
        if(!isEmpty) {
            unsigned char c = queue_deq(&mon_queue.q);
            return c;
        }
        delay_ms(10);
    }
}

void __io_putchar( char c )
{
    if(gOutputDevices & OUTPUT_TO_SERIAL) {
        SERIAL_enqueue_one_char(c);
        if(c == '\n') {
            SERIAL_flush();
        }
    }

    if(gOutputDevices & OUTPUT_TO_TEXTPORT) {
        TextportPutchar(c);
    }
}

void errorchar(char c)
{
    SERIAL_enqueue_one_char(c);
}

void errorchar_flush()
{
    SERIAL_flush();
}

//----------------------------------------------------------------------------
// File operations

void check_exceptional_conditions()
{
    if(gConsoleOverflowed) {
        logprintf(DEBUG_WARNINGS, "WARNING: Console input queue overflow\n");
        gConsoleOverflowed = 0;
    }

#ifdef USE_PS2KBD
    if(gKeyboardOverflowed) {
        logprintf(DEBUG_WARNINGS, "WARNING: Keyboard data queue overflow\n");
        gKeyboardOverflowed = 0;
    }

    if(gKeyboardParityError) {
        logprintf(DEBUG_WARNINGS, "WARNING: Keyboard data parity error, received 0x%02X\n", gKeyboardParityError - 256);
        gKeyboardParityError = 0;
    }

    if(gKeyboardBATBadParity) {
        logprintf(DEBUG_EVENTS, "EVENT: Received initial BAT with parity error from PS/2 keyboard\n");
        gKeyboardBATBadParity = 0;
    }
#endif
}

void process_local_key(unsigned char c);

void process_monitor_queue()
{
    unsigned char isEmpty = queue_isempty(&mon_queue.q);
    static unsigned char escapeBackToMonitor = 0;

    if(!isEmpty) {
        unsigned char c = queue_deq(&mon_queue.q);
        if(gSerialInputToMonitor)
            process_local_key(c);
        else {
            if(escapeBackToMonitor == 0 && c == 1)
                escapeBackToMonitor = 1;
            else if(escapeBackToMonitor != 0 && c == 2) {
                escapeBackToMonitor = 0;
                gSerialInputToMonitor = 1;
                printf("Serial input returned to monitor\n");
            } else {
                escapeBackToMonitor = 0;
                disable_interrupts();
                console_enqueue_key_unsafe(c);
                enable_interrupts();
            }
        }
    }
}

void uart_received(char c)
{
    queue_enq(&mon_queue.q, c);
}

void console_queue_init()
{
    queue_init(&con_queue.q, CON_QUEUE_CAPACITY);
}

//----------------------------------------------------------------------------
// DAC

#define DAC_VALUE_LIMIT 0xFF

#define MAX_DAC_VOLTAGE 1.22f

unsigned char voltageToDACValue(float voltage)
{
    if(voltage < 0.0f) {
        return 0x0;
    }
    uint32_t value = (uint32_t)(voltage / MAX_DAC_VOLTAGE * 255);
    if(value >= DAC_VALUE_LIMIT) {
        return DAC_VALUE_LIMIT;
    }
    return value;
}

//----------------------------------------------------------------------------
// NTSC Video goop

int SECTION_CCMRAM markHandlerInSamples = 0;

uint16_t SECTION_CCMRAM rowCyclesSpent[525];
uint32_t SECTION_CCMRAM DMAFIFOUnderruns = 0;
uint32_t SECTION_CCMRAM DMATransferErrors = 0;
typedef enum { NTSC_SOLID_FILL, NTSC_COLOR_TEST, NTSC_SCAN_TEST, NTSC_USE_VIDEO_MODE} VideoMode;
VideoMode SECTION_CCMRAM NTSCMode = NTSC_COLOR_TEST;
int SECTION_CCMRAM videoScanTestLeft = 200;
int SECTION_CCMRAM videoScanTestRight = 700;
int SECTION_CCMRAM videoScanTestTop = 50;
int SECTION_CCMRAM videoScanTestBottom = 200;

// Number of samples we target, 4x colorburst yields 227.5 cycles, or 910 samples at 14.318180MHz
// But we cheat and actually scan out 912 cycles to be a multiple
// of 16, so lines are .22% too long.  We hope the receiver is permissive
// enough to ignore this.  My cheap Orion is.

#define ROW_SAMPLES        912

#define NTSC_COLORBURST_FREQUENCY       3579545
#define NTSC_EQPULSE_LINES	3
#define NTSC_VSYNC_LINES	3
#define NTSC_VBLANK_LINES	11
#define NTSC_FRAME_LINES	525
#define NTSC_EQ_PULSE_INTERVAL	.04
#define NTSC_VSYNC_BLANK_INTERVAL	.43
#define NTSC_HOR_SYNC_DUR	.075
#define NTSC_FRAMES		(59.94 / 2)
#define NTSC_FRONTPORCH		.02
/* BACKPORCH including COLORBURST */
#define NTSC_BACKPORCH		.075
#define NTSC_COLORBURST_CYCLES  10

#define NTSC_SYNC_TIP_VOLTAGE   0.0f
#define NTSC_SYNC_PORCH_VOLTAGE   .285f
#define NTSC_SYNC_BLACK_VOLTAGE   .339f
#define NTSC_SYNC_WHITE_VOLTAGE   1.0f  /* VCR had .912v */

// These are in CCM to reduce contention with SRAM1 during DMA 
unsigned char SECTION_CCMRAM NTSCEqSyncPulseLine[ROW_SAMPLES];
unsigned char SECTION_CCMRAM NTSCVSyncLine[ROW_SAMPLES];
unsigned char SECTION_CCMRAM NTSCBlankLine[ROW_SAMPLES];

unsigned char SECTION_CCMRAM NTSCSyncTip;
unsigned char SECTION_CCMRAM NTSCSyncPorch;
unsigned char SECTION_CCMRAM NTSCBlack;
unsigned char SECTION_CCMRAM NTSCWhite;
unsigned char SECTION_CCMRAM NTSCMaxAllowed;

int NTSCEqPulseClocks;
int NTSCVSyncClocks;
int NTSCHSyncClocks;
int NTSCLineClocks;
int NTSCFrameClocks;
int NTSCFrontPorchClocks;
int NTSCBackPorchClocks;

// Essentially the remainder of CCMRAM, will need to be shrunk if more goes into CCM
#define IMGBUFFER_SIZE  50564
// (Following was copied from paper chicken scratches)
// On Orion TV, one 14MHz clock is .0225 inches, one 240p row is .052 inches.
// So to find a close value for width, width = sqrt(4 / 3 * .052 / .0225 * IMGBUFFER_SIZE)
// Then, height should be no more than width * 3 * .0225 / (4 / .052)
// So for 53248, a reasonable 4:3 framebuffer is 400x128
// 4:3 aspect would be 1.333
// 400 wide would be 9 inches, and 128 high would be 6.656 inches, and that's 1.352, so it's not too bad
unsigned char SECTION_CCMRAM imgBuffer[IMGBUFFER_SIZE];

uint32_t SECTION_CCMRAM paletteToWave[2][256];
unsigned char SECTION_CCMRAM rowPalette[525];

// XXX these are in SRAM2 to reduce contention with SRAM1 during DMA
unsigned char __attribute__((section (".sram2"))) row0[ROW_SAMPLES];
unsigned char __attribute__((section (".sram2"))) row1[ROW_SAMPLES];
unsigned char __attribute__((section (".sram2"))) audio0[512];
unsigned char __attribute__((section (".sram2"))) audio1[512];

unsigned char NTSCYIQToDAC(float y, float i, float q, float tcycles)
{
// This is transcribed from the NTSC spec, double-checked.
    float wt = tcycles * M_PI * 2;
    float sine = sinf(wt + 33.0f / 180.0f * M_PI);
    float cosine = cosf(wt + 33.0f / 180.0f * M_PI);
    float signal = y + q * sine + i * cosine;
// end of transcription

    return voltageToDACValue(NTSC_SYNC_BLACK_VOLTAGE + signal * (NTSC_SYNC_WHITE_VOLTAGE - NTSC_SYNC_BLACK_VOLTAGE));
}

uint32_t NTSCYIQToWave(float y, float i, float q)
{
    unsigned char b0 = NTSCYIQToDAC(y, i, q,  .0f);
    unsigned char b1 = NTSCYIQToDAC(y, i, q, .25f);
    unsigned char b2 = NTSCYIQToDAC(y, i, q, .50f);
    unsigned char b3 = NTSCYIQToDAC(y, i, q, .75f);

    return (b0 << 0) | (b1 << 8) | (b2 << 16) | (b3 << 24);
}

unsigned char NTSCColorburst0;
unsigned char NTSCColorburst90;
unsigned char NTSCColorburst180;
unsigned char NTSCColorburst270;

void NTSCCalculateParameters(float clock)
{
    // Calculate values for a scanline
    NTSCFrameClocks = floorf(clock * 1000000.0 / NTSC_FRAMES + 0.5);
    // NTSCLineClocks = floorf((double)NTSCFrameClocks / NTSC_FRAME_LINES + 0.5);
    NTSCLineClocks = ROW_SAMPLES;
    NTSCHSyncClocks = floorf(NTSCLineClocks * NTSC_HOR_SYNC_DUR + 0.5);
    NTSCFrontPorchClocks = NTSCLineClocks * NTSC_FRONTPORCH;
    NTSCBackPorchClocks = NTSCLineClocks * NTSC_BACKPORCH;
    NTSCEqPulseClocks = NTSCLineClocks * NTSC_EQ_PULSE_INTERVAL;
    NTSCVSyncClocks = NTSCLineClocks * NTSC_VSYNC_BLANK_INTERVAL;

    NTSCSyncTip = voltageToDACValue(NTSC_SYNC_TIP_VOLTAGE);
    NTSCSyncPorch = voltageToDACValue(NTSC_SYNC_PORCH_VOLTAGE);
    NTSCBlack = voltageToDACValue(NTSC_SYNC_BLACK_VOLTAGE);
    NTSCWhite = voltageToDACValue(NTSC_SYNC_WHITE_VOLTAGE);
    NTSCMaxAllowed = 255;

    // Calculate the four values for the colorburst that we'll repeat to make a wave
    // The waveform is defined as sine in the FCC broadcast doc, but for
    // composite the voltages are reversed, so the waveform becomes -sine.
    NTSCColorburst0 = NTSCSyncPorch;
    NTSCColorburst90 = NTSCSyncPorch - .6 * NTSCSyncPorch;
    NTSCColorburst180 = NTSCSyncPorch;
    NTSCColorburst270 = NTSCSyncPorch + .6 * NTSCSyncPorch;

    // System palette entries
    paletteToWave[1][255] = paletteToWave[0][255] = 
        (NTSCWhite <<  0) |
        (NTSCWhite <<  8) |
        (NTSCWhite << 16) |
        (NTSCWhite << 24);
    paletteToWave[1][254] = paletteToWave[0][254] = 
        (NTSCBlack <<  0) |
        (NTSCBlack <<  8) |
        (NTSCBlack << 16) |
        (NTSCBlack << 24);

    memset(rowPalette, 0, sizeof(rowPalette));

    memset(row0, NTSCSyncPorch, sizeof(row0));
    memset(row1, NTSCSyncPorch, sizeof(row1));
}

void NTSCFillEqPulseLine(unsigned char *rowBuffer)
{
    for (int col = 0; col < NTSCLineClocks; col++) {
        if (col < NTSCEqPulseClocks || (col > NTSCLineClocks/2 && col < NTSCLineClocks/2 + NTSCEqPulseClocks)) {
            rowBuffer[col] = NTSCSyncTip;
        } else {
            rowBuffer[col] = NTSCSyncPorch;
        }
    }
}

void NTSCFillVSyncLine(unsigned char *rowBuffer)
{
    for (int col = 0; col < NTSCLineClocks; col++) {
        if (col < NTSCVSyncClocks || (col > NTSCLineClocks/2 && col < NTSCLineClocks/2 + NTSCVSyncClocks)) {
            rowBuffer[col] = NTSCSyncTip;
        } else {
            rowBuffer[col] = NTSCSyncPorch;
        }
    }
}

// Haven't accelerated because not yet done in scan ISR
void NTSCAddColorburst(unsigned char *rowBuffer)
{
    static const int startOfColorburstClocks = 80; // XXX magic number for current clock

    for(int col = startOfColorburstClocks; col < startOfColorburstClocks + NTSC_COLORBURST_CYCLES * 4; col++) {
        switch((col - startOfColorburstClocks) % 4) {
            case 0: rowBuffer[col] = NTSCColorburst0; break;
            case 1: rowBuffer[col] = NTSCColorburst90; break;
            case 2: rowBuffer[col] = NTSCColorburst180; break;
            case 3: rowBuffer[col] = NTSCColorburst270; break;
        }
    }
}

void NTSCFillBlankLine(unsigned char *rowBuffer, int withColorburst)
{
    for (int col = 0; col < NTSCLineClocks; col++) {
        if (col < NTSCHSyncClocks) {
            rowBuffer[col] = NTSCSyncTip;
        } else {
            rowBuffer[col] = NTSCSyncPorch;
        }
    }
    if(withColorburst) {
        NTSCAddColorburst(rowBuffer);
    }
}

void NTSCGenerateLineBuffers()
{
    // one line = (1 / 3579545) * (455/2)

    // front porch is (.165) * (1 / 15734) / (1 / 3579545) = 37.53812921062726565701 cycles (37.5)
    //     74 cycles at double clock
    // pixels is (1 - .165) * (1 / 15734) / (1 / 3579545) = 189.96568418711380557696 cycles (190)
    //     280 cycles at double clock

    NTSCFillEqPulseLine(NTSCEqSyncPulseLine);
    NTSCFillVSyncLine(NTSCVSyncLine);
    NTSCFillBlankLine(NTSCBlankLine, 1);
}

int NTSCSetRowPalette(int row, int palette)
{
    rowPalette[row] = palette;
    return 0;
}

static const VideoModeEntry NTSCModes[];
VideoFillRowFunc SECTION_CCMRAM VideoCurrentFillRow;
uint32_t SECTION_CCMRAM solidFillWave;


void NTSCFillRowBuffer(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    // XXX could optimize these by having one branch be lines < 21
    /*
     * Rows 0 through 8 are equalizing pulse, then vsync, then equalizing pulse
     */
    if(lineNumber < NTSC_EQPULSE_LINES) {

        memcpy(rowBuffer, NTSCEqSyncPulseLine, sizeof(NTSCEqSyncPulseLine));

    } else if(lineNumber - NTSC_EQPULSE_LINES < NTSC_VSYNC_LINES) {

        memcpy(rowBuffer, NTSCVSyncLine, sizeof(NTSCVSyncLine));

    } else if(lineNumber - (NTSC_EQPULSE_LINES + NTSC_VSYNC_LINES) < NTSC_EQPULSE_LINES) {

        memcpy(rowBuffer, NTSCEqSyncPulseLine, sizeof(NTSCEqSyncPulseLine));

    } else if(lineNumber - (NTSC_EQPULSE_LINES + NTSC_VSYNC_LINES + NTSC_EQPULSE_LINES) < NTSC_VBLANK_LINES) {

        /*
         * Rows 9 through 2X are other part of vertical blank
         */

        // XXX should just change DMA source address, then this needs to be in SRAM2
        memcpy(rowBuffer, NTSCBlankLine, sizeof(NTSCBlankLine));

    } else if(lineNumber >= 263 && lineNumber <= 271) {
        // Interlacing handling weird lines
        if(lineNumber <= 264) {
            //lines 263, 264 - last 405 of eq pulse then first 405 of eq pulse
            memcpy(rowBuffer, NTSCEqSyncPulseLine + ROW_SAMPLES / 2, ROW_SAMPLES / 2);
            memcpy(rowBuffer + ROW_SAMPLES / 2, NTSCEqSyncPulseLine, ROW_SAMPLES / 2);
        } else if(lineNumber == 265) {
            //line 265 - last 405 of eq pulse then first 405 of vsync
            memcpy(rowBuffer, NTSCEqSyncPulseLine + ROW_SAMPLES / 2, ROW_SAMPLES / 2);
            memcpy(rowBuffer + ROW_SAMPLES / 2, NTSCVSyncLine, ROW_SAMPLES / 2);
        } else if(lineNumber <= 267) {
            //lines 266, 267 - last 405 of vsync then first 405 of vsync
            memcpy(rowBuffer, NTSCVSyncLine + ROW_SAMPLES / 2, ROW_SAMPLES / 2);
            memcpy(rowBuffer + ROW_SAMPLES / 2, NTSCVSyncLine, ROW_SAMPLES / 2);
        } else if(lineNumber == 268) {
            //lines 268 - last 405 of vsync then first 405 of eq pulse
            memcpy(rowBuffer, NTSCVSyncLine + ROW_SAMPLES / 2, ROW_SAMPLES / 2);
            memcpy(rowBuffer + ROW_SAMPLES / 2, NTSCEqSyncPulseLine, ROW_SAMPLES / 2);
        } else if(lineNumber <= 270) {
            //lines 269, 270 - last 405 of eq pulse then first 405 of eq pulse
            memcpy(rowBuffer, NTSCEqSyncPulseLine + ROW_SAMPLES / 2, ROW_SAMPLES / 2);
            memcpy(rowBuffer + ROW_SAMPLES / 2, NTSCEqSyncPulseLine, ROW_SAMPLES / 2);
        } else if(lineNumber == 271) {
            //line 271 - last 405 of eq pulse then 405 of SyncPorch
            memcpy(rowBuffer, NTSCEqSyncPulseLine + ROW_SAMPLES / 2, ROW_SAMPLES / 2);
            memset(rowBuffer + ROW_SAMPLES / 2, NTSCSyncPorch, ROW_SAMPLES / 2);
        }

    } else if((lineNumber >= 272) && (lineNumber <= 281)) { // XXX half line at 282

        /*
         * Rows 272 through 2XX are other part of vertical blank
         */

        // XXX should just change DMA source address, then this needs to be in SRAM2
        memcpy(rowBuffer, NTSCBlankLine, sizeof(NTSCBlankLine));

    } else {

        // Don't need to do these because did both buffers at some point during vertical blank?
        memcpy(rowBuffer, NTSCBlankLine, NTSCHSyncClocks + NTSCBackPorchClocks);
        memcpy(rowBuffer + ROW_SAMPLES - NTSCFrontPorchClocks, NTSCBlankLine + ROW_SAMPLES - NTSCFrontPorchClocks, NTSCFrontPorchClocks);

        // 244 lines
        // 189 columns @ 4 per pixel
        int y = lineNumber - (NTSC_EQPULSE_LINES + NTSC_VSYNC_LINES + NTSC_EQPULSE_LINES + NTSC_VBLANK_LINES);

        switch(NTSCMode) {
            case NTSC_COLOR_TEST: {
                if((y > 20 && y < 230) || (y > 283 && y < 493)) {
                    
                    // Clear pixels outside of text area 
                    memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, 80);
                    int clocksToRightEdge = 169 * 4;
                    memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

                    unsigned char *rowOut = rowBuffer + (NTSCHSyncClocks + NTSCBackPorchClocks + 3) / 4 * 4 + 20 * 4;
                    uint32_t* rowWords = (uint32_t*)rowOut;
                    unsigned char v = NTSCBlack + (NTSCWhite - NTSCBlack) / 2;
                    unsigned char a = NTSCWhite;
                    unsigned char c = NTSCBlack;
                    uint32_t colorWord = (v << 0) | (v << 8) | (v << 16) | (v << 24); // little endian
                    for(int col = 20; col < 50; col++) {
                        *rowWords++ = colorWord;
                    }
                    colorWord = (v << 0) | (a << 8) | (v << 16) | (c << 24); // little endian
                    for(int col = 50; col < 169; col++) {
                        *rowWords++ = colorWord;
                    }
                }
                break;
            }
            case NTSC_SOLID_FILL: {
                if((y % 263) > 20 && (y % 263) < 230) {
                    unsigned char *rowOut = rowBuffer + (NTSCHSyncClocks + NTSCBackPorchClocks + 3) / 4 * 4 + 20 * 4;
                    uint32_t* rowWords = (uint32_t*)rowOut;
                    for(int col = 20; col < 169; col++) {
                        *rowWords++ = solidFillWave;
                    }
                }
                break;
            }
            case NTSC_SCAN_TEST: {
                if((lineNumber % 263) >= videoScanTestTop && (lineNumber % 263) <= videoScanTestBottom) {
                    for(int row = videoScanTestLeft; row < videoScanTestRight; row++) {
                        rowBuffer[row] = 200;
                    }
                }
                break;
            }
            case NTSC_USE_VIDEO_MODE: {
                VideoCurrentFillRow(frameNumber, lineNumber, rowBuffer);
                break;
            }
        }
        if(lineNumber == 262) {
            //line 262 - overwrite last 405 samples with first 405 samples of EQ pulse
            memcpy(rowBuffer + ROW_SAMPLES / 2, NTSCEqSyncPulseLine, ROW_SAMPLES / 2);
        } else if(lineNumber == 282) {
            //special line 282 - write SyncPorch from BackPorch to middle of line after mode's fillRow()
            memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCSyncPorch, ROW_SAMPLES / 2 - (NTSCHSyncClocks + NTSCBackPorchClocks));
        }
    }
    // if(lineNumber == 0) { rowBuffer[0] = 255;}
}

// debug overlay scanout

int SECTION_CCMRAM debugOverlayEnabled = 0;

#define debugDisplayWidth 19
#define debugDisplayHeight 13
#define debugDisplayLeftTick (NTSCHSyncClocks + NTSCBackPorchClocks + 48)
#define debugDisplayTopTick (NTSC_EQPULSE_LINES + NTSC_VSYNC_LINES + NTSC_EQPULSE_LINES + NTSC_VBLANK_LINES + 20)
/* debugFontWidthScale != 4 looks terrible in a color field because of adjacent color columns; probably need to ensure 0s around any 1 text column */
#define debugFontWidthScale 4
#define debugCharGapPixels 1
#define debugFontHeightScale 1

char SECTION_CCMRAM debugDisplay[debugDisplayHeight][debugDisplayWidth];

#include "8x16.h"
// static int font8x16Width = 8, font8x16Height = 16;
// static unsigned char font8x16Bits[] = /* was a bracket here */

void fillRowDebugOverlay(int frameNumber, int lineNumber, unsigned char* nextRowBuffer)
{
    uint32_t NTSCWhiteLong =
        (NTSCWhite <<  0) |
        (NTSCWhite <<  8) |
        (NTSCWhite << 16) |
        (NTSCWhite << 24);
    int debugFontScanlineHeight = font8x16Height * debugFontHeightScale;

    int rowWithinDebugArea = (lineNumber % 263) - debugDisplayTopTick;
    int charRow = rowWithinDebugArea / debugFontScanlineHeight;
    int charPixelY = (rowWithinDebugArea % debugFontScanlineHeight) / debugFontHeightScale;

// XXX this code assumes font width <= 8 and each row padded out to a byte
    if((rowWithinDebugArea >= 0) && (charRow < debugDisplayHeight)) {
        for(int charCol = 0; charCol < debugDisplayWidth; charCol++) {
            unsigned char debugChar = debugDisplay[charRow][charCol];
            if(debugChar != 0) {
                unsigned char charRowBits = font8x16Bits[debugChar * font8x16Height + charPixelY];
#if debugFontWidthScale == 4 && font8x16Width == 8
                unsigned char *charPixels = nextRowBuffer + debugDisplayLeftTick + (charCol * (font8x16Width + debugCharGapPixels)) * debugFontWidthScale;
                if(charRowBits & 0x80) { ((uint32_t*)charPixels)[0] = NTSCWhiteLong; } 
                if(charRowBits & 0x40) { ((uint32_t*)charPixels)[1] = NTSCWhiteLong; }
                if(charRowBits & 0x20) { ((uint32_t*)charPixels)[2] = NTSCWhiteLong; }
                if(charRowBits & 0x10) { ((uint32_t*)charPixels)[3] = NTSCWhiteLong; }
                if(charRowBits & 0x08) { ((uint32_t*)charPixels)[4] = NTSCWhiteLong; }
                if(charRowBits & 0x04) { ((uint32_t*)charPixels)[5] = NTSCWhiteLong; }
                if(charRowBits & 0x02) { ((uint32_t*)charPixels)[6] = NTSCWhiteLong; }
                if(charRowBits & 0x01) { ((uint32_t*)charPixels)[7] = NTSCWhiteLong; }
#else
                for(int charPixelX = 0; charPixelX < font8x16Width; charPixelX++) {
                    int pixel = charRowBits & (0x80 >> charPixelX);
                    if(pixel) {
                        unsigned char *charPixels = nextRowBuffer + debugDisplayLeftTick + (charCol * (font8x16Width + debugCharGapPixels) + charPixelX) * debugFontWidthScale;
#if debugFontWidthScale == 4
                        *(uint32_t *)charPixels = NTSCWhiteLong; 
#else
                        for(int col = 0; col < debugFontWidthScale; col++) {
                            charPixels[col] = NTSCWhite;
                        }
#endif
                    }
                }
#endif
            }
        }
    }
}

volatile int SECTION_CCMRAM lineNumber = 0;
volatile int SECTION_CCMRAM frameNumber = 0;

void MemoryCopyDMA(unsigned char* dst, unsigned char* src, size_t size)
{
    // XXX wait on previous DMA
    // Configure DMA to copy tmp row
    DMA2_Stream1->CR &= ~DMA_SxCR_EN;       /* disable DMA2_1 */
    DMA2->LIFCR = 0xF00;                        /* clear flags */
    DMA2_Stream1->NDTR = size / 4;
    DMA2_Stream1->PAR = (uint32_t)src;        // Source buffer address 0 in Memory-to-Memory mode
    DMA2_Stream1->M0AR = (uint32_t)dst;        // Dest buffer address in Memory-to-Memory mode
    DMA2_Stream1->FCR = DMA_FIFOMODE_ENABLE |   // Enable FIFO to improve stutter
        0; // DMA_FIFO_THRESHOLD_FULL;        
    DMA2_Stream1->CR =
        DMA_CHANNEL_1 |                         
        DMA_MEMORY_TO_MEMORY |                  // Memory to Memory
        DMA_PDATAALIGN_WORD | // DMA_PBURST_INC4 |
        DMA_MDATAALIGN_WORD | // DMA_MBURST_INC4 |
        DMA_PRIORITY_LOW |
        DMA_PINC_ENABLE |                       // Increment memory address
        DMA_MINC_ENABLE |                       // Increment memory address
        0;
    DMA2_Stream1->CR |= DMA_SxCR_EN;    /* enable DMA */
}

// XXX audio experiment
// In this mode we woud have a sampling rate of 15.6998 KHz
unsigned char SECTION_CCMRAM audioBuffer[256];
volatile int audioBufferPosition = 0;

int doPlay(int argc, char **argv)
{
    int bufferHalfSize = sizeof(audioBuffer) / 2;

    char *filename = argv[1];
    FIL file;
    FRESULT result = f_open (&file, filename, FA_READ | FA_OPEN_EXISTING);
    if(result) {
        logprintf(DEBUG_ERRORS, "ERROR: couldn't open \"%s\" for reading, FatFS result %d\n", filename, result);
        return 1;
    }

    int where = 0;

    UINT wasread;
    do {
        // Wait for audio to get past the buffer we read
        while((audioBufferPosition - where + sizeof(audioBuffer)) % sizeof(audioBuffer) < bufferHalfSize);
        result = f_read(&file, audioBuffer + where, bufferHalfSize, &wasread);
        if(result) {
            logprintf(DEBUG_ERRORS, "ERROR: couldn't read block of audio from \"%s\", result %d\n", filename, result);
            memset(audioBuffer, 128, sizeof(audioBuffer));
            return COMMAND_FAILED;
        }
        where = (where + bufferHalfSize) % sizeof(audioBuffer);
        LED_beat_heart();
    } while(wasread == bufferHalfSize);

    f_close(&file);

    while((audioBufferPosition - where + sizeof(audioBuffer)) % sizeof(audioBuffer) < bufferHalfSize);
    memset(audioBuffer, 128, sizeof(audioBuffer));

    return COMMAND_CONTINUE;
}

static void RegisterCommandPlay(void) __attribute__((constructor));
static void RegisterCommandPlay(void)
{
    RegisterApp("play", 2, doPlay, "filename",
        "play 15.7KHz u8 mono audio stream"
        );
}

void DMA2_Stream2_IRQHandler(void)
{
    // Configure timer TIM2 for performance measurement
    // TIM9->SR = 0;                       /* reset status */
    // TIM9->ARR = 0xFFFFFFFF;
    TIM9->CNT = 0;
    TIM9->CR1 = TIM_CR1_CEN;            /* enable the timer */

    // Clear interrupt flag
    DMA2->LIFCR |= DMA_LIFCR_CTCIF2;
    // DMA2->LIFCR |= DMA_LIFCR_CHTIF2;

    if(markHandlerInSamples) {
        for(int i = 0; i < 28; i++) { GPIOC->ODR = 0xFFFFFFF8; }
    } else {
        // Do a little loop here since FIFO may have starved a little on interrupt
        // And hope we're early enough in the line that values aren't changing
        uint32_t GPIOJ_ODR = GPIOJ->ODR;
        for(int i = 0; i < 15; i++) { GPIOJ->ODR = GPIOJ_ODR; }
    }

    if(DMA2->LISR & DMA_FLAG_FEIF2_6) {
        DMA2->LIFCR |= DMA_LIFCR_CFEIF2;
        DMAFIFOUnderruns++;
    }
    if(DMA2->LISR & DMA_FLAG_TEIF2_6) {
        DMA2->LIFCR |= DMA_LIFCR_CTEIF2;
        DMATransferErrors++;
    }

#if 0
    // XXX audio experiment
    DAC1->DHR8R1 = audioBuffer[audioBufferPosition];
    audioBufferPosition = (audioBufferPosition + 1) % sizeof(audioBuffer);
#endif

    int whichIsScanning = (DMA2_Stream2->CR & DMA_SxCR_CT) ? 1 : 0;

    unsigned char *nextRowBuffer = (whichIsScanning == 1) ? row0 : row1;

    NTSCFillRowBuffer(frameNumber, lineNumber, nextRowBuffer);
    if(debugOverlayEnabled) {
        fillRowDebugOverlay(frameNumber, lineNumber, nextRowBuffer);
    }

    lineNumber = lineNumber + 1;
    if(lineNumber == NTSC_FRAME_LINES) {
        lineNumber = 0;
        frameNumber++;
    }

    TIM9->CR1 = 0;            /* stop the timer */
    rowCyclesSpent[lineNumber] = TIM9->CNT;     // TIM9 CK_INT is RCC

    // A little pulse so we know where we are on the line
    if(markHandlerInSamples) {
        for(int i = 0; i < 28; i++) { GPIOC->ODR = 0xFFFFFFE8; }
    }
}

void DMAStartScanout(uint32_t dmaCount)
{
    // Configure DAC
    GPIO_InitTypeDef  GPIO_InitStruct = {0};
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Pin = 0xFF;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 

    // Enable DMA interrupt handler
    HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 1);
    HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);

    // Configure DMA
    DMA2_Stream2->NDTR = ROW_SAMPLES;
    DMA2_Stream2->M0AR = (uint32_t)row0;        // Source buffer address 0
    DMA2_Stream2->M1AR = (uint32_t)row1;        // Source buffer address 1 
    DMA2_Stream2->PAR = (uint32_t)&GPIOC->ODR;  // Destination address
    DMA2_Stream2->FCR = DMA_FIFOMODE_ENABLE |   // Enable FIFO to improve stutter
        DMA_FIFO_THRESHOLD_FULL;        
    DMA2_Stream2->CR =
        DMA_CHANNEL_6 |                         // which channel is driven by which timer to which peripheral is limited
        DMA_MEMORY_TO_PERIPH |                  // Memory to Peripheral
        DMA_PDATAALIGN_BYTE |                   // BYTES to peripheral
        DMA_MDATAALIGN_WORD | DMA_MBURST_INC4 |
        DMA_SxCR_DBM |                          // double buffer
        DMA_PRIORITY_VERY_HIGH |                // Video data must be highest priority, can't stutter
        DMA_MINC_ENABLE |                       // Increment memory address
        DMA_IT_TC |                             // Interrupt on transfer complete of each buffer
        // DMA_IT_HT |                             // Interrupt on transfer complete of each buffer 
        0;

    // Configure TIM1_CH2 to drive DMA
    TIM1->CCR2 = (dmaCount + 1) / 2;         /* 50% duty cycle, although I've tried 1 and dmacount-1 and nothing seems to change.  Is this used? */ 
    TIM1->CCER |= TIM_CCER_CC2E;        /* enable capture/compare CH2 */
    TIM1->DIER |= TIM_DIER_CC2DE;       /* enable capture/compare updates DMA */

    // Configure timer TIM1
    TIM1->SR = 0;                       /* reset status */
    TIM1->ARR = dmaCount - 1;           /* load the register with this */

    lineNumber = 1; // Next up is row 1
    frameNumber = 0; 

    // Clear FIFO and transfer error flags
    DMA2->LIFCR |= DMA_LIFCR_CFEIF2;
    DMA2->LIFCR |= DMA_LIFCR_CTEIF2;

    DMA2_Stream2->CR |= DMA_SxCR_EN;    /* enable DMA */
    TIM1->CR1 = TIM_CR1_CEN;            /* enable the timer */
}

void DMAStopScanout()
{
    DMA2_Stream2->CR &= ~DMA_SxCR_EN;       /* disable DMA */
    TIM1->CR1 &= ~TIM_CR1_CEN;            /* disable the timer */
}

//----------------------------------------------------------------------------
// Video modes 

#define font8x8Width 8
#define font8x8Height 8

unsigned char SECTION_CCMRAM font8x8Bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x12, 0x10,
    0x7C, 0x10, 0x12, 0x7C, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x00, 0x04, 0x08, 0x3C, 0x42, 0x7E, 0x40, 0x3C, 0x00, 0x24,
    0x00, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x08, 0x14, 0x08, 0x14,
    0x22, 0x3E, 0x22, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x02, 0x02, 0x00,
    0x00, 0x14, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x1D, 0x22,
    0x26, 0x2A, 0x32, 0x22, 0x5C, 0x00, 0x10, 0x08, 0x42, 0x42, 0x42,
    0x46, 0x3A, 0x00, 0x32, 0x4C, 0x00, 0x2C, 0x32, 0x22, 0x22, 0x00,
    0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x38,
    0x04, 0x3C, 0x44, 0x3A, 0x00, 0x3E, 0x7A, 0x44, 0x44, 0x78, 0x48,
    0x44, 0x00, 0x14, 0x00, 0x08, 0x14, 0x22, 0x3E, 0x22, 0x00, 0x32,
    0x4C, 0x08, 0x14, 0x22, 0x3E, 0x22, 0x00, 0x32, 0x4C, 0x22, 0x32,
    0x2A, 0x26, 0x22, 0x00, 0x00, 0x14, 0x1C, 0x22, 0x22, 0x22, 0x1C,
    0x00, 0x09, 0x16, 0x26, 0x2A, 0x32, 0x34, 0x48, 0x00, 0x32, 0x4C,
    0x00, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x3C, 0x22, 0x22, 0x3C, 0x22,
    0x22, 0x7C, 0x00, 0x24, 0x00, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x00,
    0x32, 0x4C, 0x00, 0x18, 0x24, 0x24, 0x18, 0x00, 0x1C, 0x2A, 0x0A,
    0x1C, 0x28, 0x2A, 0x1C, 0x00, 0x28, 0x00, 0x38, 0x04, 0x3C, 0x44,
    0x3A, 0x00, 0x20, 0x10, 0x38, 0x04, 0x3C, 0x44, 0x3A, 0x00, 0x10,
    0x00, 0x38, 0x04, 0x3C, 0x44, 0x3A, 0x00, 0x3C, 0x40, 0x7C, 0x42,
    0x3E, 0x02, 0x3C, 0x00, 0x04, 0x08, 0x3E, 0x20, 0x3E, 0x20, 0x3E,
    0x00, 0x08, 0x1E, 0x24, 0x26, 0x3C, 0x24, 0x26, 0x00, 0x1C, 0x22,
    0x20, 0x20, 0x22, 0x1C, 0x08, 0x10, 0x00, 0x00, 0x32, 0x4C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x24, 0x24, 0x24,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x7E, 0x24, 0x7E, 0x24,
    0x24, 0x00, 0x08, 0x1E, 0x28, 0x1C, 0x0A, 0x3C, 0x08, 0x00, 0x00,
    0x62, 0x64, 0x08, 0x10, 0x26, 0x46, 0x00, 0x30, 0x48, 0x48, 0x30,
    0x4A, 0x44, 0x3A, 0x00, 0x04, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x04, 0x08, 0x10, 0x10, 0x10, 0x08, 0x04, 0x00, 0x20, 0x10,
    0x08, 0x08, 0x08, 0x10, 0x20, 0x00, 0x08, 0x2A, 0x1C, 0x3E, 0x1C,
    0x2A, 0x08, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00,
    0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x3C,
    0x42, 0x46, 0x5A, 0x62, 0x42, 0x3C, 0x00, 0x08, 0x18, 0x28, 0x08,
    0x08, 0x08, 0x3E, 0x00, 0x3C, 0x42, 0x02, 0x0C, 0x30, 0x40, 0x7E,
    0x00, 0x3C, 0x42, 0x02, 0x1C, 0x02, 0x42, 0x3C, 0x00, 0x04, 0x0C,
    0x14, 0x24, 0x7E, 0x04, 0x04, 0x00, 0x7E, 0x40, 0x78, 0x04, 0x02,
    0x44, 0x38, 0x00, 0x1C, 0x20, 0x40, 0x7C, 0x42, 0x42, 0x3C, 0x00,
    0x7E, 0x42, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00, 0x3C, 0x42, 0x42,
    0x3C, 0x42, 0x42, 0x3C, 0x00, 0x3C, 0x42, 0x42, 0x3E, 0x02, 0x04,
    0x38, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x08, 0x00, 0x00, 0x08, 0x08, 0x10, 0x06, 0x0C, 0x18, 0x30,
    0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x3C, 0x42,
    0x02, 0x0C, 0x10, 0x00, 0x10, 0x00, 0x1C, 0x22, 0x4A, 0x56, 0x4C,
    0x20, 0x1E, 0x00, 0x18, 0x24, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00,
    0x7C, 0x22, 0x22, 0x3C, 0x22, 0x22, 0x7C, 0x00, 0x1C, 0x22, 0x40,
    0x40, 0x40, 0x22, 0x1C, 0x00, 0x78, 0x24, 0x22, 0x22, 0x22, 0x24,
    0x78, 0x00, 0x7E, 0x40, 0x40, 0x78, 0x40, 0x40, 0x7E, 0x00, 0x7E,
    0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x00, 0x1C, 0x22, 0x40, 0x4E,
    0x42, 0x22, 0x1C, 0x00, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42,
    0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x0E, 0x04,
    0x04, 0x04, 0x04, 0x44, 0x38, 0x00, 0x42, 0x44, 0x48, 0x70, 0x48,
    0x44, 0x42, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00,
    0x42, 0x66, 0x5A, 0x5A, 0x42, 0x42, 0x42, 0x00, 0x42, 0x62, 0x52,
    0x4A, 0x46, 0x42, 0x42, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42,
    0x3C, 0x00, 0x7C, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00, 0x3C,
    0x42, 0x42, 0x42, 0x4A, 0x44, 0x3A, 0x00, 0x7C, 0x42, 0x42, 0x7C,
    0x48, 0x44, 0x42, 0x00, 0x3C, 0x42, 0x40, 0x3C, 0x02, 0x42, 0x3C,
    0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x42, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x42, 0x42, 0x42, 0x24, 0x24,
    0x18, 0x18, 0x00, 0x42, 0x42, 0x42, 0x5A, 0x5A, 0x66, 0x42, 0x00,
    0x42, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42, 0x00, 0x22, 0x22, 0x22,
    0x1C, 0x08, 0x08, 0x08, 0x00, 0x7E, 0x02, 0x04, 0x18, 0x20, 0x40,
    0x7E, 0x00, 0x3C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x00, 0x00,
    0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x3C, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x3C, 0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x10, 0x08,
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x04, 0x3C,
    0x44, 0x3A, 0x00, 0x40, 0x40, 0x5C, 0x62, 0x42, 0x62, 0x5C, 0x00,
    0x00, 0x00, 0x3C, 0x42, 0x40, 0x42, 0x3C, 0x00, 0x02, 0x02, 0x3A,
    0x46, 0x42, 0x46, 0x3A, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x7E, 0x40,
    0x3C, 0x00, 0x0C, 0x12, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x00, 0x00,
    0x00, 0x3A, 0x46, 0x46, 0x3A, 0x02, 0x3C, 0x40, 0x40, 0x5C, 0x62,
    0x42, 0x42, 0x42, 0x00, 0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x1C,
    0x00, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x44, 0x38, 0x40, 0x40,
    0x44, 0x48, 0x50, 0x68, 0x44, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x1C, 0x00, 0x00, 0x00, 0x76, 0x49, 0x49, 0x49, 0x49, 0x00,
    0x00, 0x00, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x3C,
    0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x5C, 0x62, 0x62, 0x5C,
    0x40, 0x40, 0x00, 0x00, 0x3A, 0x46, 0x46, 0x3A, 0x02, 0x02, 0x00,
    0x00, 0x5C, 0x62, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3E, 0x40,
    0x3C, 0x02, 0x7C, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x12, 0x0C,
    0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x00, 0x00, 0x00,
    0x42, 0x42, 0x42, 0x24, 0x18, 0x00, 0x00, 0x00, 0x41, 0x49, 0x49,
    0x49, 0x36, 0x00, 0x00, 0x00, 0x42, 0x24, 0x18, 0x24, 0x42, 0x00,
    0x00, 0x00, 0x42, 0x42, 0x46, 0x3A, 0x02, 0x3C, 0x00, 0x00, 0x7E,
    0x04, 0x18, 0x20, 0x7E, 0x00, 0x0C, 0x10, 0x10, 0x20, 0x10, 0x10,
    0x0C, 0x00, 0x08, 0x08, 0x08, 0x00, 0x08, 0x08, 0x08, 0x00, 0x30,
    0x08, 0x08, 0x04, 0x08, 0x08, 0x30, 0x00, 0x30, 0x49, 0x06, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x3E,
    0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x7F, 0x3E, 0x08, 0x08, 0x00, 0x36,
    0x7F, 0x7F, 0x3E, 0x1C, 0x08, 0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E,
    0x1C, 0x08, 0x00, 0x1C, 0x1C, 0x08, 0x6B, 0x7F, 0x6B, 0x08, 0x1C,
    0x3C, 0x42, 0xA5, 0x81, 0xA5, 0x99, 0x42, 0x3C, 0x3C, 0x42, 0xA5,
    0x81, 0x99, 0xA5, 0x42, 0x3C, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08,
    0x04, 0x3C, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x3C, 0x00,
    0x00, 0x39, 0x46, 0x46, 0x39, 0x00, 0x00, 0x3C, 0x22, 0x3C, 0x22,
    0x22, 0x3C, 0x20, 0x40, 0x61, 0x12, 0x14, 0x18, 0x10, 0x30, 0x30,
    0x00, 0x0C, 0x12, 0x10, 0x0C, 0x0A, 0x12, 0x0C, 0x00, 0x06, 0x08,
    0x10, 0x3E, 0x10, 0x08, 0x06, 0x00, 0x16, 0x06, 0x08, 0x10, 0x1C,
    0x02, 0x0C, 0x00, 0x2C, 0x52, 0x12, 0x12, 0x02, 0x02, 0x02, 0x00,
    0x08, 0x14, 0x22, 0x3E, 0x22, 0x14, 0x08, 0x00, 0x00, 0x20, 0x20,
    0x20, 0x22, 0x22, 0x1C, 0x00, 0x40, 0x48, 0x50, 0x60, 0x50, 0x4A,
    0x44, 0x00, 0x20, 0x10, 0x10, 0x10, 0x18, 0x24, 0x42, 0x00, 0x24,
    0x24, 0x24, 0x24, 0x3A, 0x20, 0x20, 0x00, 0x00, 0x00, 0x32, 0x12,
    0x14, 0x18, 0x10, 0x00, 0x08, 0x1C, 0x20, 0x18, 0x20, 0x1C, 0x02,
    0x0C, 0x00, 0x18, 0x24, 0x42, 0x42, 0x24, 0x18, 0x00, 0x00, 0x00,
    0x3E, 0x54, 0x14, 0x14, 0x14, 0x00, 0x00, 0x18, 0x24, 0x24, 0x38,
    0x20, 0x20, 0x00, 0x00, 0x00, 0x3E, 0x48, 0x48, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x3E, 0x48, 0x08, 0x08, 0x08, 0x08, 0x00, 0x02, 0x64,
    0x24, 0x24, 0x24, 0x18, 0x00, 0x08, 0x1C, 0x2A, 0x2A, 0x2A, 0x1C,
    0x08, 0x00, 0x00, 0x00, 0x62, 0x14, 0x08, 0x14, 0x23, 0x00, 0x49,
    0x2A, 0x2A, 0x1C, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x22, 0x41,
    0x49, 0x49, 0x36, 0x00, 0x1C, 0x22, 0x41, 0x41, 0x63, 0x22, 0x63,
    0x00, 0x1E, 0x10, 0x10, 0x10, 0x50, 0x30, 0x10, 0x00, 0x00, 0x08,
    0x00, 0x3E, 0x00, 0x08, 0x00, 0x00, 0x7E, 0x20, 0x10, 0x0C, 0x10,
    0x20, 0x7E, 0x00, 0x00, 0x32, 0x4C, 0x00, 0x32, 0x4C, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x14, 0x22, 0x7F, 0x00, 0x00, 0x04, 0x08, 0x10,
    0x10, 0x08, 0x08, 0x10, 0x20, 0x01, 0x02, 0x7F, 0x08, 0x7F, 0x20,
    0x40, 0x00, 0x10, 0x08, 0x04, 0x3E, 0x10, 0x08, 0x04, 0x00, 0x3F,
    0x52, 0x24, 0x08, 0x12, 0x25, 0x42, 0x00, 0x1C, 0x22, 0x41, 0x41,
    0x7F, 0x22, 0x22, 0x63, 0x00, 0x00, 0x36, 0x49, 0x49, 0x36, 0x00,
    0x00, 0x00, 0x02, 0x04, 0x48, 0x50, 0x60, 0x40, 0x00, 0x1E, 0x20,
    0x1C, 0x22, 0x1C, 0x02, 0x3C, 0x00, 0x22, 0x55, 0x2A, 0x14, 0x2A,
    0x55, 0x22, 0x00, 0x3C, 0x42, 0x9D, 0xA1, 0xA1, 0x9D, 0x42, 0x3C,
    0x42, 0x24, 0x18, 0x24, 0x18, 0x24, 0x42, 0x00, 0x3E, 0x4A, 0x4A,
    0x3A, 0x0A, 0x0A, 0x0A, 0x0A, 0x08, 0x1C, 0x2A, 0x28, 0x2A, 0x1C,
    0x08, 0x00, 0x3C, 0x7A, 0xA5, 0xA5, 0xB9, 0xA9, 0x66, 0x3C, 0x5F,
    0x60, 0x63, 0x62, 0x64, 0x7B, 0x60, 0x5F, 0xFF, 0x04, 0x03, 0xFC,
    0x02, 0xFC, 0x04, 0xF8, 0xFC, 0x02, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x78, 0x44, 0x44, 0x78, 0x4A, 0x44, 0x4B, 0x00, 0x61, 0x82,
    0x84, 0x68, 0x16, 0x29, 0x49, 0x86, 0x0E, 0x06, 0x0A, 0x70, 0x90,
    0x90, 0x60, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x08, 0x1C, 0x08,
    0x0E, 0x08, 0x08, 0x0E, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE3, 0xDD,
    0xF3, 0xF7, 0xFF, 0xF7, 0xFF, 0x08, 0x14, 0x08, 0x1C, 0x2A, 0x08,
    0x14, 0x22, 0x08, 0x14, 0x08, 0x1C, 0x2A, 0x14, 0x3E, 0x14, 0x08,
    0x14, 0x22, 0x22, 0x22, 0x2A, 0x36, 0x22, 0x22, 0x14, 0x08, 0x3E,
    0x08, 0x3E, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x20,
    0x00, 0x1C, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x04, 0x04, 0x04, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x7E, 0x02, 0x7E, 0x02, 0x04, 0x08, 0x00, 0x00, 0x00, 0x3E,
    0x02, 0x0C, 0x08, 0x10, 0x00, 0x00, 0x00, 0x02, 0x04, 0x0C, 0x14,
    0x04, 0x00, 0x00, 0x00, 0x08, 0x3E, 0x22, 0x04, 0x08, 0x00, 0x00,
    0x00, 0x00, 0x3E, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x04, 0x3E,
    0x0C, 0x14, 0x24, 0x00, 0x00, 0x00, 0x10, 0x3E, 0x12, 0x14, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x04, 0x3E, 0x00, 0x00, 0x00,
    0x3C, 0x04, 0x1C, 0x04, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x2A,
    0x02, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x7E, 0x02, 0x16, 0x18, 0x10, 0x20, 0x00, 0x02, 0x04, 0x08,
    0x18, 0x28, 0x48, 0x08, 0x00, 0x10, 0x7E, 0x42, 0x02, 0x02, 0x04,
    0x08, 0x00, 0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x04,
    0x7E, 0x0C, 0x14, 0x24, 0x44, 0x04, 0x00, 0x10, 0x7E, 0x12, 0x12,
    0x12, 0x22, 0x44, 0x00, 0x08, 0x7F, 0x08, 0x7F, 0x08, 0x08, 0x08,
    0x00, 0x20, 0x3E, 0x22, 0x42, 0x04, 0x08, 0x10, 0x00, 0x20, 0x3E,
    0x48, 0x08, 0x08, 0x08, 0x10, 0x00, 0x00, 0x7E, 0x02, 0x02, 0x02,
    0x02, 0x7E, 0x00, 0x24, 0x7E, 0x24, 0x24, 0x04, 0x08, 0x10, 0x00,
    0x00, 0x60, 0x02, 0x62, 0x02, 0x04, 0x38, 0x00, 0x00, 0x3E, 0x02,
    0x04, 0x08, 0x14, 0x22, 0x00, 0x10, 0x7E, 0x11, 0x12, 0x10, 0x10,
    0x0E, 0x00, 0x00, 0x42, 0x22, 0x02, 0x04, 0x08, 0x10, 0x00, 0x20,
    0x3E, 0x22, 0x52, 0x0C, 0x08, 0x10, 0x00, 0x04, 0x38, 0x08, 0x7E,
    0x08, 0x08, 0x10, 0x00, 0x00, 0x52, 0x52, 0x52, 0x02, 0x04, 0x08,
    0x00, 0x00, 0x3C, 0x00, 0x7E, 0x08, 0x08, 0x10, 0x00, 0x10, 0x10,
    0x10, 0x18, 0x14, 0x12, 0x10, 0x00, 0x08, 0x08, 0x7E, 0x08, 0x08,
    0x08, 0x10, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00,
    0x00, 0x3E, 0x02, 0x14, 0x08, 0x14, 0x22, 0x00, 0x10, 0x7E, 0x04,
    0x08, 0x14, 0x32, 0x50, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10,
    0x20, 0x00, 0x00, 0x10, 0x08, 0x44, 0x42, 0x42, 0x42, 0x00, 0x40,
    0x40, 0x7E, 0x40, 0x40, 0x40, 0x3E, 0x00, 0x7E, 0x02, 0x02, 0x02,
    0x02, 0x04, 0x18, 0x00, 0x00, 0x10, 0x28, 0x44, 0x02, 0x01, 0x01,
    0x00, 0x08, 0x7F, 0x08, 0x08, 0x49, 0x49, 0x08, 0x00, 0x7E, 0x02,
    0x02, 0x24, 0x18, 0x08, 0x04, 0x00, 0x40, 0x3C, 0x00, 0x3C, 0x00,
    0x7C, 0x02, 0x00, 0x08, 0x10, 0x20, 0x40, 0x42, 0x7E, 0x02, 0x00,
    0x02, 0x02, 0x14, 0x08, 0x14, 0x20, 0x40, 0x00, 0x00, 0x7E, 0x10,
    0x7E, 0x10, 0x10, 0x0E, 0x00, 0x10, 0x10, 0x7E, 0x12, 0x14, 0x10,
    0x10, 0x00, 0x00, 0x3C, 0x04, 0x04, 0x04, 0x04, 0x7F, 0x00, 0x3E,
    0x02, 0x02, 0x3E, 0x02, 0x02, 0x3E, 0x00, 0x3C, 0x00, 0x7E, 0x02,
    0x02, 0x04, 0x08, 0x00, 0x44, 0x44, 0x44, 0x44, 0x04, 0x08, 0x10,
    0x00, 0x10, 0x50, 0x50, 0x50, 0x52, 0x54, 0x58, 0x00, 0x40, 0x40,
    0x40, 0x44, 0x48, 0x50, 0x60, 0x00, 0x00, 0x7E, 0x42, 0x42, 0x42,
    0x42, 0x7E, 0x00, 0x00, 0x7E, 0x42, 0x42, 0x02, 0x04, 0x08, 0x00,
    0x00, 0x60, 0x00, 0x02, 0x02, 0x04, 0x78, 0x00, 0x10, 0x48, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x00,
};

// Video mode specifics follow

int SetPaletteEntryAlwaysFails(const VideoModeEntry* modeEntry, int palette, int which, float r, float g, float b)
{
    return 0;
}

void SetPaletteEntry(int palette, int which, float r, float g, float b)
{
    float y, i, q;
    RGBToYIQ(r, g, b, &y, &i, &q);
    paletteToWave[palette][which] = NTSCYIQToWave(y, i, q);
}

int SetRowPalette(const struct VideoModeEntry* modeEntry, int row, int palette)
{
    return NTSCSetRowPalette(row, palette);
}

const static float HSVFor4BitPalette[][3] = {
    { M_PI / 3 * 0, 1.0, 1.0 },
    { M_PI / 3 * 1, 1.0, 1.0 },
    { M_PI / 3 * 2, 1.0, 1.0 },
    { M_PI / 3 * 3, 1.0, 1.0 },
    { M_PI / 3 * 4, 1.0, 1.0 },
    { M_PI / 3 * 5, 1.0, 1.0 },
    { M_PI / 3 * 0, 0.25, 0.5 },
    { M_PI / 3 * 1, 0.25, 0.5 },
    { M_PI / 3 * 2, 0.25, 0.5 },
    { M_PI / 3 * 3, 0.25, 0.5 },
    { M_PI / 3 * 4, 0.25, 0.5 },
    { M_PI / 3 * 5, 0.25, 0.5 },
    { 0.0, 0.0, 1.0},
    { 0.0, 0.0, .66},
    { 0.0, 0.0, .33},
    { 0.0, 0.0, .0},
};

static void MakeDefaultPalette(int whichPalette, int paletteSize)
{
    switch(paletteSize) {
        case -1: break; /* no palette */
        case 16:  {
            for(int entry = 0; entry < 16; entry++) {
                const float *hsv = HSVFor4BitPalette[entry];
                float r, g, b;
                HSVToRGB3f(hsv[0], hsv[1], hsv[2], &r, &g, &b);
                SetPaletteEntry(whichPalette, entry, r, g, b);
            }
            break;
        }
        case 256: {
            // H3S2V3
            for(unsigned int entry = 0; entry < 256; entry++) {
                float h = ((entry >> 5) & 7) / 7.0f * M_PI * 2;
                float s = ((entry >> 3) & 3) / 3.0f;
                float v = ((entry >> 0) & 7) / 7.0f;
                float r, g, b;
                HSVToRGB3f(h, s, v, &r, &g, &b);
                SetPaletteEntry(whichPalette, entry, r, g, b);
            }
        }
    }
}


// ----------------------------------------
// plain 40x24 black-on-white textport

#define TextportPlain40x24Width 40
#define TextportPlain40x24Height 24
#define TextportPlain40x24TopTick 44
#define TextportPlain40x24LeftTick 196

int TextportPlain40x24CursorX = 0;
int TextportPlain40x24CursorY = 0;
int TextportPlain40x24CursorFlash = 1;

// Textport video mode structs
const static VideoTextportInfo TextportPlain40x24Info = {
    TextportPlain40x24Width, TextportPlain40x24Height,
    TEXT_8BIT_BLACK_ON_WHITE,
};

void TextportPlain40x24Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 0);        /* monochrome text */
}

void TextportPlain40x24GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoTextportInfo *info = (VideoTextportInfo*)modeEntry->info;
    VideoTextportParameters *params = (VideoTextportParameters*)params_;
    params->base = imgBuffer;
    params->cursorX = &TextportPlain40x24CursorX;
    params->cursorY = &TextportPlain40x24CursorY;
    params->rowSize = info->width;
}

void TextportPlain40x24FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithinArea = (lineNumber % 263) - TextportPlain40x24TopTick;
    int charRow = rowWithinArea / font8x8Height;
    int charPixelY = (rowWithinArea % font8x8Height);

    int invert = (TextportPlain40x24CursorFlash == 0) || (frameNumber / 15 % 2 == 0);

// XXX this code assumes font width <= 8 and each row padded out to a byte
    if((rowWithinArea >= 0) && (charRow < TextportPlain40x24Height)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCWhite, TextportPlain40x24LeftTick - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightTextEdge = TextportPlain40x24LeftTick + TextportPlain40x24Width * font8x8Width * 2;
        memset(rowBuffer + clocksToRightTextEdge, NTSCWhite, ROW_SAMPLES - clocksToRightTextEdge - NTSCFrontPorchClocks);

        for(int charCol = 0; charCol < TextportPlain40x24Width; charCol++) {
            unsigned char whichChar = imgBuffer[charRow * TextportPlain40x24Width + charCol];
            unsigned char charRowBits = font8x8Bits[whichChar * font8x8Height + charPixelY];
            unsigned char *charPixels = rowBuffer + TextportPlain40x24LeftTick + charCol * font8x8Width * 2;
            int invertThis = (charCol == TextportPlain40x24CursorX && charRow == TextportPlain40x24CursorY && invert);
            for(int charPixelX = 0; charPixelX < font8x8Width; charPixelX++) {
                int pixel = (charRowBits & (0x80 >> charPixelX)) ^ invertThis;
                charPixels[charPixelX * 2 + 0] = pixel ? NTSCBlack : NTSCWhite;
                charPixels[charPixelX * 2 + 1] = pixel ? NTSCBlack : NTSCWhite;
            }
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCWhite, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

// ----------------------------------------
// plain 80x24 white-on-black textport

// 196, 832, 44, 236
#define TextportPlain80x24Width 80
#define TextportPlain80x24Height 24
#define TextportPlain80x24TopTick 44
#define TextportPlain80x24LeftTick 196

int TextportPlain80x24CursorX = 0;
int TextportPlain80x24CursorY = 0;
int TextportPlain80x24CursorFlash = 0;

// Textport video mode structs
const static VideoTextportInfo TextportPlain80x24Info = {
    TextportPlain80x24Width, TextportPlain80x24Height,
    TEXT_8BIT_WHITE_ON_BLACK,
};

void TextportPlain80x24Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 0);        /* monochrome text */
}

void TextportPlain80x24GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoTextportInfo *info = (VideoTextportInfo*)modeEntry->info;
    VideoTextportParameters *params = (VideoTextportParameters*)params_;
    params->base = imgBuffer;
    params->cursorX = &TextportPlain80x24CursorX;
    params->cursorY = &TextportPlain80x24CursorY;
    params->rowSize = info->width;
}

int TextportPlain80x24SetPaletteEntry(const VideoModeEntry* modeEntry, int palette, int which, float r, float g, float b)
{
    return 0;
}

void TextportPlain80x24FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithinArea = (lineNumber % 263) - TextportPlain80x24TopTick;
    int charRow = rowWithinArea / font8x8Height;
    int charPixelY = (rowWithinArea % font8x8Height);

    int invert = (TextportPlain80x24CursorFlash == 0) || (frameNumber / 15 % 2 == 0);

// XXX this code assumes font width <= 8 and each row padded out to a byte
    if((rowWithinArea >= 0) && (charRow < TextportPlain80x24Height)) {
        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, TextportPlain80x24LeftTick - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightTextEdge = TextportPlain80x24LeftTick + TextportPlain80x24Width * font8x8Width;
        memset(rowBuffer + clocksToRightTextEdge, NTSCBlack, ROW_SAMPLES - clocksToRightTextEdge - NTSCFrontPorchClocks);

        for(int charCol = 0; charCol < TextportPlain80x24Width; charCol++) {
            unsigned char whichChar = imgBuffer[charRow * TextportPlain80x24Width + charCol];
            unsigned char charRowBits = font8x8Bits[whichChar * font8x8Height + charPixelY];
            unsigned char *charPixels = rowBuffer + TextportPlain80x24LeftTick + charCol * font8x8Width;
            int invertThis = (charCol == TextportPlain80x24CursorX && charRow == TextportPlain80x24CursorY && invert);
            if(invertThis) {
                for(int charPixelX = 0; charPixelX < font8x8Width; charPixelX++) {
                    int pixel = charRowBits & (0x80 >> charPixelX);
                    charPixels[charPixelX] = pixel ? NTSCBlack : NTSCWhite;
                }
            } else {
                for(int charPixelX = 0; charPixelX < font8x8Width; charPixelX++) {
                    int pixel = charRowBits & (0x80 >> charPixelX);
                    charPixels[charPixelX] = pixel ? NTSCWhite : NTSCBlack;
                }
            }
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

// ----------------------------------------
// highest-horizontal-resolution 8-bit framebuffer

#define MAX_RES_MODE_WIDTH 384
#define MAX_RES_MODE_HEIGHT 128

#if IMGBUFFER_SIZE < MAX_RES_MODE_WIDTH * MAX_RES_MODE_HEIGHT
#error imgBuffer has become too small for MaxRes mode.
#endif

// Pixmap video mode structs
const static VideoPixmapInfo ColorMaxResInfo = {
    MAX_RES_MODE_WIDTH, MAX_RES_MODE_HEIGHT,
    PALETTE_8BIT,
    256,
    1,
    1,
    225, 225 / 4 * 3 * MAX_RES_MODE_WIDTH / MAX_RES_MODE_HEIGHT,
};


void ColorMaxResSetup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 1);
    MakeDefaultPalette(0, 256);
    for(int y = 0; y < MAX_RES_MODE_HEIGHT; y++) {
        rowPalette[y] = 0;
    }
}

void ColorMaxResGetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoPixmapInfo *info = (VideoPixmapInfo*)modeEntry->info;
    VideoPixmapParameters *params = (VideoPixmapParameters*)params_;
    params->base = imgBuffer;
    params->rowSize = info->width;
}

// 510 and 142 are magic numbers measured for middle of screen
#define ColorMaxResLeft (512 - MAX_RES_MODE_WIDTH / 2) 
#define ColorMaxResWidth MAX_RES_MODE_WIDTH
#define ColorMaxResTop (142 - MAX_RES_MODE_HEIGHT / 2)
#define ColorMaxResHeight MAX_RES_MODE_HEIGHT

int ColorMaxResSetPaletteEntry(const VideoModeEntry* modeEntry, int palette, int which, float r, float g, float b)
{
    if(which >= 256) {
        return 1;
    }
    SetPaletteEntry(palette, which, r, g, b);
    return 0;
}

// XXX assumes ColorMaxResLeft is /4 and ColorMaxResWidth /4
void ColorMaxResFillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) - ColorMaxResTop;

    if((rowWithin >= 0) && (rowWithin < ColorMaxResHeight)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ColorMaxResLeft - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = ColorMaxResLeft + ColorMaxResWidth;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        unsigned char *srcPixels = imgBuffer + rowWithin * ColorMaxResWidth;
        uint32_t *dstWords = (uint32_t*)(rowBuffer + ColorMaxResLeft);

        uint32_t *palette = paletteToWave[rowPalette[rowWithin]];

        for(int i = 0; i < ColorMaxResWidth; i += 4) {
            uint32_t waveformPart0 = palette[srcPixels[i + 0]] & 0x000000FF;
            uint32_t waveformPart1 = palette[srcPixels[i + 1]] & 0x0000FF00;
            uint32_t waveformPart2 = palette[srcPixels[i + 2]] & 0x00FF0000;
            uint32_t waveformPart3 = palette[srcPixels[i + 3]] & 0xFF000000;
            *dstWords++ = waveformPart0 | waveformPart1 | waveformPart2 | waveformPart3;
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}


// ----------------------------------------
// 175 x 230 8-bit pixmap display
// to be /4, 164, 864, 27, 257

#define Color175x230Left 164
#define Color175x230WidthSamples 700
#define Color175x230WidthPixels (Color175x230WidthSamples / 4)
#define Color175x230PixelRowBytes Color175x230WidthPixels
#define Color175x230Top 27
#define Color175x230Height 230

#if IMGBUFFER_SIZE < Color175x230PixelRowBytes * Color175x230Height
#error imgBuffer has become too small for Color175x230 mode.
#endif

// Pixmap video mode structs
const static VideoPixmapInfo Color175x230Info = {
    Color175x230WidthSamples / 4, Color175x230Height,
    PALETTE_8BIT,
    256,
    1,
    1,
    900, 520,
};

void Color175x230Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 1);
    MakeDefaultPalette(0, 256);
    for(int y = 0; y < Color175x230Height; y++) {
        rowPalette[y] = 0;
    }
}

void Color175x230GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoPixmapInfo *info = (VideoPixmapInfo*)modeEntry->info;
    VideoPixmapParameters *params = (VideoPixmapParameters*)params_;
    params->base = imgBuffer;
    params->rowSize = info->width;
}

int Color175x230SetPaletteEntry(const VideoModeEntry* modeEntry, int palette, int which, float r, float g, float b)
{
    if(which >= 256) {
        return 1;
    }
    SetPaletteEntry(palette, which, r, g, b);
    return 0;
}

void Color175x230FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) - Color175x230Top;

    if((rowWithin >= 0) && (rowWithin < Color175x230Height)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, Color175x230WidthSamples - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = Color175x230Left + Color175x230WidthSamples;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        unsigned char *srcPixels = imgBuffer + rowWithin * (Color175x230WidthSamples / 4);
        unsigned char *dstBytes = rowBuffer + Color175x230Left;

        uint32_t *palette = paletteToWave[rowPalette[rowWithin]];

        for(int i = 0; i < Color175x230WidthSamples; i += 4) {
            int p = srcPixels[i / 4];
            uint32_t word = palette[p];
            *(uint32_t*)(dstBytes + i) = word;
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

// ----------------------------------------
// 160 x 192 8-bit bitmap display
// 196, 832, 44, 236

#define Color160x192Left 196
#define Color160x192WidthSamples 640
#define Color160x192WidthPixels (Color160x192WidthSamples / 4)
#define Color160x192PixelRowBytes Color160x192WidthPixels
#define Color160x192Top 44
#define Color160x192Height 192

#if IMGBUFFER_SIZE < Color160x192PixelRowBytes * Color160x192Height
#error imgBuffer has become too small for Color160x192 mode.
#endif

// Pixmap video mode structs
const static VideoPixmapInfo Color160x192Info = {
    Color160x192WidthSamples / 4, Color160x192Height,
    PALETTE_8BIT,
    256,
    1,
    0,
    900, 520,
};

void Color160x192Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 1);
    MakeDefaultPalette(0, 256);
    for(int y = 0; y < Color160x192Height; y++) {
        rowPalette[y] = 0;
    }
}

void Color160x192GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoPixmapInfo *info = (VideoPixmapInfo*)modeEntry->info;
    VideoPixmapParameters *params = (VideoPixmapParameters*)params_;
    params->base = imgBuffer;
    params->rowSize = info->width;
}

int Color160x192SetPaletteEntry(const VideoModeEntry* modeEntry, int palette, int which, float r, float g, float b)
{
    if(which >= 256) {
        return 1;
    }
    SetPaletteEntry(palette, which, r, g, b);
    return 0;
}

void Color160x192FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) - Color160x192Top;

    if((rowWithin >= 0) && (rowWithin < Color160x192Height)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, Color160x192WidthSamples - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = Color160x192Left + Color160x192WidthSamples;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        unsigned char *srcPixels = imgBuffer + rowWithin * (Color160x192WidthSamples / 4);
        unsigned char *dstBytes = rowBuffer + Color160x192Left;

        uint32_t *palette = paletteToWave[rowPalette[rowWithin]];

        for(int i = 0; i < Color160x192WidthSamples; i += 4) {
            int p = srcPixels[i / 4];
            uint32_t word = palette[p];
            *(uint32_t*)(dstBytes + i) = word;
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

// ----------------------------------------
// 350 x 230 4-bit bitmap display
// to be /4, 164, 864, 27, 257

#define Color350x230Left 164
#define Color350x230WidthSamples 700
#define Color350x230WidthPixels (Color350x230WidthSamples / 2)
#define Color350x230PixelRowBytes (Color350x230WidthPixels / 2)
#define Color350x230Top 27
#define Color350x230Height 230

#if IMGBUFFER_SIZE < Color350x230PixelRowBytes * Color350x230Height
#error imgBuffer has become too small for Color350x230 mode.
#endif

// Pixmap video mode structs
const static VideoPixmapInfo Color350x230Info = {
    Color350x230WidthSamples / 2, Color350x230Height,
    PALETTE_4BIT,
    16,
    1,
    1,
    450, 520,
};

void Color350x230Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 1);
    MakeDefaultPalette(0, 16);
    for(int y = 0; y < Color350x230Height; y++) {
        rowPalette[y] = 0;
    }
}

void Color350x230GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoPixmapInfo *info = (VideoPixmapInfo*)modeEntry->info;
    VideoPixmapParameters *params = (VideoPixmapParameters*)params_;
    params->base = imgBuffer;
    params->rowSize = info->width / 2;
}

int Color350x230SetPaletteEntry(const VideoModeEntry* modeEntry, int palette, int which, float r, float g, float b)
{
    if(which >= 16) {
        return 1;
    }
    SetPaletteEntry(palette, which, r, g, b);
    return 0;
}

void Color350x230FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) - Color350x230Top;

    if((rowWithin >= 0) && (rowWithin < Color350x230Height)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, Color350x230WidthSamples - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = Color350x230Left + Color350x230WidthSamples;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        unsigned char *srcPixels = imgBuffer + rowWithin * (Color350x230WidthSamples / 4);
        unsigned char *dstBytes = rowBuffer + Color350x230Left;

        uint32_t *palette = paletteToWave[rowPalette[rowWithin]];

        for(int i = 0; i < Color350x230WidthSamples / 2; i++) { /* loop over pixels */

            int colWithin = i;
            int whichByte = colWithin / 2;
            int whichNybble = colWithin % 2;
            int p = (srcPixels[whichByte] >> (whichNybble * 4)) & 0xF;

            uint32_t word = palette[p];
            uint32_t waveWordShift = whichNybble * 16;

            *dstBytes++ = (word >> (waveWordShift + 0)) & 0xFF;
            *dstBytes++ = (word >> (waveWordShift + 8)) & 0xFF;
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

// ----------------------------------------
// 320 x 192 4-bit bitmap display
// 196, 832, 44, 236

#define Color320x192Left 196
#define Color320x192WidthSamples 640
#define Color320x192WidthPixels (Color320x192WidthSamples / 2)
#define Color320x192PixelRowBytes (Color320x192WidthPixels / 2)
#define Color320x192Top 44
#define Color320x192Height 192

#if IMGBUFFER_SIZE < Color320x192PixelRowBytes * Color320x192Height
#error imgBuffer has become too small for Color320x192 mode.
#endif

// Pixmap video mode structs
const static VideoPixmapInfo Color320x192Info = {
    Color320x192WidthSamples / 2, Color320x192Height,
    PALETTE_4BIT,
    16,
    1,
    0,
    450, 520,
};

void Color320x192Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 1);
    MakeDefaultPalette(0, 16);
    for(int y = 0; y < Color320x192Height; y++) {
        rowPalette[y] = 0;
    }
}

void Color320x192GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoPixmapInfo *info = (VideoPixmapInfo*)modeEntry->info;
    VideoPixmapParameters *params = (VideoPixmapParameters*)params_;
    params->base = imgBuffer;
    params->rowSize = info->width / 2;
}

int Color320x192SetPaletteEntry(const VideoModeEntry* modeEntry, int palette, int which, float r, float g, float b)
{
    if(which >= 16) {
        return 1;
    }
    SetPaletteEntry(palette, which, r, g, b);
    return 0;
}

void Color320x192FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) - Color320x192Top;

    if((rowWithin >= 0) && (rowWithin < Color320x192Height)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, Color320x192WidthSamples - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = Color320x192Left + Color320x192WidthSamples;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        unsigned char *srcPixels = imgBuffer + rowWithin * (Color320x192WidthSamples / 4);
        unsigned char *dstBytes = rowBuffer + Color320x192Left;

        uint32_t *palette = paletteToWave[rowPalette[rowWithin]];

        for(int i = 0; i < Color320x192WidthSamples / 2; i++) { /* loop over pixels */

            int colWithin = i;
            int whichByte = colWithin / 2;
            int whichNybble = colWithin % 2;
            int p = (srcPixels[whichByte] >> (whichNybble * 4)) & 0xF;

            uint32_t word = palette[p];
            uint32_t waveWordShift = whichNybble * 16;

            *dstBytes++ = (word >> (waveWordShift + 0)) & 0xFF;
            *dstBytes++ = (word >> (waveWordShift + 8)) & 0xFF;
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

// ----------------------------------------
// 704 x 230 4-gray pixmap display
// to be /8, 164, 868, 27, 257

#define Grayscale704x230Left 164
#define Grayscale704x230WidthSamples 704
#define Grayscale704x230WidthPixels Grayscale704x230WidthSamples
#define Grayscale704x230PixelRowBytes (Grayscale704x230WidthPixels / 4)
#define Grayscale704x230Top 27
#define Grayscale704x230Height 230

#if IMGBUFFER_SIZE < Grayscale704x230PixelRowBytes * Grayscale704x230Height
#error imgBuffer has become too small for Grayscale704x230 mode.
#endif

// Pixmap video mode structs
const static VideoPixmapInfo Grayscale704x230Info = {
    Grayscale704x230WidthSamples, Grayscale704x230Height,
    GRAY_2BIT,
    -1,
    0,
    1,
    225, 520,
};

void Grayscale704x230Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 0);        /* grayscale mode */
}

void Grayscale704x230GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoPixmapInfo *info = (VideoPixmapInfo*)modeEntry->info;
    VideoPixmapParameters *params = (VideoPixmapParameters*)params_;
    params->base = imgBuffer;
    params->rowSize = info->width / 4;
}

void Grayscale704x230FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) - Grayscale704x230Top;

    if((rowWithin >= 0) && (rowWithin < Grayscale704x230Height)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, Grayscale704x230WidthSamples - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = Grayscale704x230Left + Grayscale704x230WidthSamples;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        unsigned char *bitmapRow = imgBuffer + rowWithin * (Grayscale704x230WidthSamples / 4);
        uint32_t *dstWords = (uint32_t*)(rowBuffer + Grayscale704x230Left);

        /* 1 byte is 4 pixels and each pixel is one samples wide so 1 byte yields 4 samples */
        for(int i = 0; i < Grayscale704x230WidthSamples / 4; i++) {
            unsigned char byte = *bitmapRow++;

            unsigned char sample0 = NTSCBlack + (NTSCWhite - NTSCBlack) * ((byte >> 0) & 0x03) / 0x03;
            unsigned char sample1 = NTSCBlack + (NTSCWhite - NTSCBlack) * ((byte >> 2) & 0x03) / 0x03;
            unsigned char sample2 = NTSCBlack + (NTSCWhite - NTSCBlack) * ((byte >> 4) & 0x03) / 0x03;
            unsigned char sample3 = NTSCBlack + (NTSCWhite - NTSCBlack) * ((byte >> 6) & 0x03) / 0x03;

            *dstWords++ = (sample3 << 24) | (sample2 << 16) | (sample1 << 8) | sample0;
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

// ----------------------------------------
// 704 x 230 monochrome bitmap display
// to be /8, 164, 868, 27, 257

#define Bitmap704x230Left 164
#define Bitmap704x230WidthSamples 704
#define Bitmap704x230WidthPixels Bitmap704x230WidthSamples
#define Bitmap704x230PixelRowBytes (Bitmap704x230WidthPixels / 8)
#define Bitmap704x230Top 27
#define Bitmap704x230Height 230

#if IMGBUFFER_SIZE < Bitmap704x230PixelRowBytes * Bitmap704x230Height
#error imgBuffer has become too small for Bitmap704x230 mode.
#endif

// Pixmap video mode structs
const static VideoPixmapInfo Bitmap704x230Info = {
    Bitmap704x230WidthSamples, Bitmap704x230Height,
    BITMAP,
    -1,
    0,
    1,
    225, 520,
};

void Bitmap704x230Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 0);        /* monochrome text */
}

void Bitmap704x230GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoPixmapInfo *info = (VideoPixmapInfo*)modeEntry->info;
    VideoPixmapParameters *params = (VideoPixmapParameters*)params_;
    params->base = imgBuffer;
    params->rowSize = info->width / 8;
}

uint32_t SECTION_CCMRAM NybblesToMasks[16] = {
    0x00000000,
    0x000000FF,
    0x0000FF00,
    0x0000FFFF,
    0x00FF0000,
    0x00FF00FF,
    0x00FFFF00,
    0x00FFFFFF,
    0xFF000000,
    0xFF0000FF,
    0xFF00FF00,
    0xFF00FFFF,
    0xFFFF0000,
    0xFFFF00FF,
    0xFFFFFF00,
    0xFFFFFFFF,
};

void Bitmap704x230FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) - Bitmap704x230Top;

    if((rowWithin >= 0) && (rowWithin < Bitmap704x230Height)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, Bitmap704x230WidthSamples - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = Bitmap704x230Left + Bitmap704x230WidthSamples;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        unsigned char *bitmapRow = imgBuffer + rowWithin * (Bitmap704x230WidthSamples / 8);
        uint32_t *dstWords = (uint32_t*)(rowBuffer + Bitmap704x230Left);

        uint32_t whiteLong = (NTSCWhite << 24) | (NTSCWhite << 16) | (NTSCWhite << 8) | (NTSCWhite << 0);
        uint32_t blackLong = (NTSCBlack << 24) | (NTSCBlack << 16) | (NTSCBlack << 8) | (NTSCBlack << 0);

        for(int i = 0; i < Bitmap704x230WidthSamples; i += 8) {
            int whiteMask = 0;
            unsigned char byte = bitmapRow[i / 8];
            whiteMask = NybblesToMasks[byte & 0xF];
            *dstWords++ = (whiteLong & whiteMask) | (blackLong & ~whiteMask);
            whiteMask = NybblesToMasks[(byte >> 4) & 0xF];
            *dstWords++ = (whiteLong & whiteMask) | (blackLong & ~whiteMask);
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

// ----------------------------------------
// 640 x 192 monochrome bitmap display
// 196, 832, 44, 236

#define Bitmap640x192Left 196
#define Bitmap640x192WidthSamples 640
#define Bitmap640x192WidthPixels Bitmap640x192WidthSamples
#define Bitmap640x192PixelRowBytes (Bitmap640x192WidthPixels / 8)
#define Bitmap640x192Top 44
#define Bitmap640x192Height 192

#if IMGBUFFER_SIZE < Bitmap640x192PixelRowBytes * Bitmap704x230Height
#error imgBuffer has become too small for Bitmap640x192 mode.
#endif

// Pixmap video mode structs
const static VideoPixmapInfo Bitmap640x192Info = {
    Bitmap640x192WidthSamples, Bitmap640x192Height,
    BITMAP,
    -1,
    0,
    0,
    225, 520,
};

void Bitmap640x192Setup(const VideoModeEntry *modeEntry)
{
    /* const VideoTextportInfo *info = (VideoTextportInfo*)info_; */
    NTSCFillBlankLine(NTSCBlankLine, 0);        /* monochrome text */
}

void Bitmap640x192GetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    const VideoPixmapInfo *info = (VideoPixmapInfo*)modeEntry->info;
    VideoPixmapParameters *params = (VideoPixmapParameters*)params_;
    params->base = imgBuffer;
    params->rowSize = info->width / 8;
}

void Bitmap640x192FillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) - Bitmap640x192Top;

    if((rowWithin >= 0) && (rowWithin < Bitmap640x192Height)) {

        // Clear pixels outside of text area 
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, Bitmap640x192WidthSamples - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = Bitmap640x192Left + Bitmap640x192WidthSamples;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        unsigned char *bitmapRow = imgBuffer + rowWithin * (Bitmap640x192WidthSamples / 8);
        uint32_t *dstWords = (uint32_t*)(rowBuffer + Bitmap640x192Left);

        uint32_t whiteLong = (NTSCWhite << 24) | (NTSCWhite << 16) | (NTSCWhite << 8) | (NTSCWhite << 0);
        uint32_t blackLong = (NTSCBlack << 24) | (NTSCBlack << 16) | (NTSCBlack << 8) | (NTSCBlack << 0);

        for(int i = 0; i < Bitmap640x192WidthSamples; i += 8) {
            int whiteMask = 0;
            unsigned char byte = bitmapRow[i / 8];
            whiteMask = NybblesToMasks[byte & 0xF];
            *dstWords++ = (whiteLong & whiteMask) | (blackLong & ~whiteMask);
            whiteMask = NybblesToMasks[(byte >> 4) & 0xF];
            *dstWords++ = (whiteLong & whiteMask) | (blackLong & ~whiteMask);
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}

#ifdef DO_WOLF
// ----------------------------------------
// Wolfenstein-style renderer

#define WolfensteinWidthSamples 440
#define WolfensteinLeft (512 - WolfensteinWidthSamples / 2)
#define WolfensteinTop (27 * 2)
#define WolfensteinHeight (192 * 2)

// Pixmap video mode structs
const static VideoWolfensteinInfo WolfensteinInfo = {
    WolfensteinWidthSamples,
    WolfensteinHeight,
};

#define WolfensteinTextureWidth 64
#define WolfensteinTextureHeight 64

const static uint32_t *Textures[];

typedef struct WolfensteinPrivateElement {
    const uint32_t (*textureColumnBase);
    int wholePixelsHalfHeight;
    uint32_t textureRowOffsetFixed16;
    uint32_t textureRowPerScanRowFixed16;
    uint32_t bright;
} WolfensteinPrivateElement;


float clamp(float x, float a, float b)
{
    return (x < a) ? a : ((x > b) ? b : x);
}

void WolfensteinSetElements(VideoWolfensteinElement* row);

void WolfensteinGetParameters(const VideoModeEntry *modeEntry, void *params_)
{
    //const VideoWolfensteinInfo *info = (VideoWolfensteinInfo*)modeEntry->info;
    VideoWolfensteinParameters *params = (VideoWolfensteinParameters*)params_;
    params->setElements = WolfensteinSetElements;
}

void WolfensteinSetup(const VideoModeEntry *modeEntry)
{
    NTSCFillBlankLine(NTSCBlankLine, 1);
    WolfensteinPrivateElement *private = (WolfensteinPrivateElement *)imgBuffer;
    for(int i = 0; i < WolfensteinWidthSamples; i++) {
        private[i].wholePixelsHalfHeight = 20;
        private[i].bright = 0;
        private[i].textureRowPerScanRowFixed16 = 0;
        private[i].textureRowOffsetFixed16 = 0;
        private[i].textureColumnBase = Textures[0];
    }
}

// Must be "width" elements
void WolfensteinSetElements(VideoWolfensteinElement* row)
{
    WolfensteinPrivateElement *private = (WolfensteinPrivateElement *)imgBuffer;
    for(int i = 0; i < WolfensteinWidthSamples; i++) {
        private[i].bright = row[i].bright * 0x10101010;
        float pixelsHalfHeight = row[i].height / 2.0f * WolfensteinHeight;
        private[i].wholePixelsHalfHeight = roundf(pixelsHalfHeight);
        if(private[i].wholePixelsHalfHeight == 0) {
            private[i].textureRowPerScanRowFixed16 = 0;
        } else {
            private[i].textureRowPerScanRowFixed16 = 65536 * WolfensteinTextureHeight / (pixelsHalfHeight * 2);
        }
        private[i].textureRowOffsetFixed16 = private[i].textureRowPerScanRowFixed16 * (row[i].height / 2.0f * WolfensteinHeight - (private[i].wholePixelsHalfHeight - .5));
        float s = clamp(row[i].textureS, 0, .99999);

        int lod = 5;
        int offset = 0;
        int mipStorageHeight = 64;
        while((lod > 0) && (private[i].textureRowPerScanRowFixed16 > 65536) /* && (private[i].dsdx > 1.0f) */ ) {
            offset += WolfensteinTextureWidth * mipStorageHeight;
            mipStorageHeight /= 2;
            private[i].textureRowPerScanRowFixed16 /= 2;
            private[i].textureRowOffsetFixed16 /= 2;
            // private[i].dsdx /= 2;
            lod -= 1;
            s /= 2;
        }

        private[i].textureColumnBase = Textures[row[i].id] + offset + (int)floorf(s * WolfensteinTextureWidth);

        if(0) printf("%d : %p, %d, %u\n",
            i,
            private[i].textureColumnBase,
            private[i].wholePixelsHalfHeight,
            private[i].textureRowPerScanRowFixed16);
    }
}

void WolfensteinFillRow(int frameNumber, int lineNumber, unsigned char *rowBuffer)
{
    int rowWithin = (lineNumber % 263) * 2 + lineNumber / 263 - WolfensteinTop;

    if((rowWithin >= 0) && (rowWithin < WolfensteinHeight)) {

        // Clear pixels outside of area 
        // XXX These two memsets may be as much as 10% of scanline render time.
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, WolfensteinWidthSamples - NTSCHSyncClocks - NTSCBackPorchClocks);
        int clocksToRightEdge = WolfensteinLeft + WolfensteinWidthSamples;
        memset(rowBuffer + clocksToRightEdge, NTSCBlack, ROW_SAMPLES - clocksToRightEdge - NTSCFrontPorchClocks);

        int rowFromMiddle = rowWithin - WolfensteinHeight / 2;

        uint32_t *dstWords = (uint32_t*)(rowBuffer + WolfensteinLeft);
        WolfensteinPrivateElement *el = (WolfensteinPrivateElement *)imgBuffer;

        for(int i = 0; i < WolfensteinWidthSamples; i += 4, el += 4) {
            uint32_t waveform;
            int withinWall = rowFromMiddle + el[0].wholePixelsHalfHeight;
            if(withinWall >= 0 && rowFromMiddle < el[0].wholePixelsHalfHeight) {
                int textureRow = (withinWall * el[0].textureRowPerScanRowFixed16 + el[0].textureRowOffsetFixed16) / 65536;
                waveform = (el[0].textureColumnBase[textureRow * WolfensteinTextureWidth] + el[0].bright) & 0x000000FF;
            } else {
                waveform = 0x00000070;
            }
            withinWall = rowFromMiddle + el[1].wholePixelsHalfHeight;
            if(withinWall >= 0 && rowFromMiddle < el[1].wholePixelsHalfHeight) {
                int textureRow = (withinWall * el[1].textureRowPerScanRowFixed16 + el[1].textureRowOffsetFixed16) / 65536;
                waveform |= (el[1].textureColumnBase[textureRow * WolfensteinTextureWidth] + el[1].bright) & 0x0000FF00;
            } else {
                waveform |= 0x00007000;
            }
            withinWall = rowFromMiddle + el[2].wholePixelsHalfHeight;
            if(withinWall >= 0 && rowFromMiddle < el[2].wholePixelsHalfHeight) {
                int textureRow = (withinWall * el[2].textureRowPerScanRowFixed16 + el[2].textureRowOffsetFixed16) / 65536;
                waveform |= (el[2].textureColumnBase[textureRow * WolfensteinTextureWidth] + el[2].bright) & 0x00FF0000;
            } else {
                waveform |= 0x00700000;
            }
            withinWall = rowFromMiddle + el[3].wholePixelsHalfHeight;
            if(withinWall >= 0 && rowFromMiddle < el[3].wholePixelsHalfHeight) {
                int textureRow = (withinWall * el[3].textureRowPerScanRowFixed16 + el[3].textureRowOffsetFixed16) / 65536;
                waveform |= (el[3].textureColumnBase[textureRow * WolfensteinTextureWidth] + el[3].bright) & 0xFF000000;
            } else {
                waveform |= 0x70000000;
            }
            *dstWords++ = waveform;
        }
    } else {
        memset(rowBuffer + NTSCHSyncClocks + NTSCBackPorchClocks, NTSCBlack, ROW_SAMPLES - NTSCHSyncClocks - NTSCBackPorchClocks - NTSCFrontPorchClocks);
    }
}


#endif

// ----------------------------------------
// Video mode table

const static VideoModeEntry NTSCModes[] =
{
    {
        VIDEO_MODE_TEXTPORT,
        &TextportPlain40x24Info,
        TextportPlain40x24Setup,
        TextportPlain40x24GetParameters,
        TextportPlain40x24FillRow,
        SetPaletteEntryAlwaysFails,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_TEXTPORT,
        &TextportPlain80x24Info,
        TextportPlain80x24Setup,
        TextportPlain80x24GetParameters,
        TextportPlain80x24FillRow,
        SetPaletteEntryAlwaysFails,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_PIXMAP,
        &Bitmap640x192Info,
        Bitmap640x192Setup,
        Bitmap640x192GetParameters,
        Bitmap640x192FillRow,
        SetPaletteEntryAlwaysFails,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_PIXMAP,
        &Color320x192Info,
        Color320x192Setup,
        Color320x192GetParameters,
        Color320x192FillRow,
        Color320x192SetPaletteEntry,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_PIXMAP,
        &Color160x192Info,
        Color160x192Setup,
        Color160x192GetParameters,
        Color160x192FillRow,
        Color160x192SetPaletteEntry,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_PIXMAP,
        &Bitmap704x230Info,
        Bitmap704x230Setup,
        Bitmap704x230GetParameters,
        Bitmap704x230FillRow,
        SetPaletteEntryAlwaysFails,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_PIXMAP,
        &Color350x230Info,
        Color350x230Setup,
        Color350x230GetParameters,
        Color350x230FillRow,
        Color350x230SetPaletteEntry,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_PIXMAP,
        &Color175x230Info,
        Color175x230Setup,
        Color175x230GetParameters,
        Color175x230FillRow,
        Color175x230SetPaletteEntry,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_PIXMAP,
        &ColorMaxResInfo,
        ColorMaxResSetup,
        ColorMaxResGetParameters,
        ColorMaxResFillRow,
        ColorMaxResSetPaletteEntry,
        SetRowPalette,
        NULL,
    },
    {
        VIDEO_MODE_PIXMAP,
        &Grayscale704x230Info,
        Grayscale704x230Setup,
        Grayscale704x230GetParameters,
        Grayscale704x230FillRow,
        SetPaletteEntryAlwaysFails,
        SetRowPalette,
        NULL,
    },
#ifdef DO_WOLF
    {
        VIDEO_MODE_WOLFENSTEIN,
        &WolfensteinInfo,
        WolfensteinSetup,
        WolfensteinGetParameters,
        WolfensteinFillRow,
        SetPaletteEntryAlwaysFails,
        SetRowPalette,
        NULL,
    },
#endif
};

// Generic videomode functions

int SECTION_CCMRAM CurrentVideoMode = -1;

int VideoGetModeCount()
{
    return sizeof(NTSCModes) / sizeof(NTSCModes[0]);
}

enum VideoModeType VideoModeGetType(int n)
{
    return NTSCModes[n].type;
}

void VideoModeGetInfo(int n, void *info)
{
    const VideoModeEntry* entry = NTSCModes + n;
    switch(entry->type) {
        case VIDEO_MODE_PIXMAP: {
            *(VideoPixmapInfo*)info = *(VideoPixmapInfo*)entry->info;
            break;
        }
        case VIDEO_MODE_TEXTPORT: {
            *(VideoTextportInfo*)info = *(VideoTextportInfo*)entry->info;
            break;
        }
        case VIDEO_MODE_SEGMENTS: {
            break;
        }
        case VIDEO_MODE_DCT: {
            break;
        }
        case VIDEO_MODE_WOZ: {
            break;
        }
        case VIDEO_MODE_TMS9918A: {
            break;
        }
        case VIDEO_MODE_WOLFENSTEIN: {
            *(VideoWolfensteinInfo*)info = *(VideoWolfensteinInfo*)entry->info;
            break;
        }
    }
}

void VideoSetMode(int n)
{
    const VideoModeEntry* entry = NTSCModes + n;
    entry->setup(entry);
    CurrentVideoMode = n;
    VideoCurrentFillRow = entry->fillRow;
}

int VideoGetCurrentMode()
{
    return CurrentVideoMode;
}

void VideoModeGetParameters(void *params)
{
    const VideoModeEntry* entry = NTSCModes + CurrentVideoMode;
    entry->getParameters(entry, params);
}

int VideoModeSetPaletteEntry(int palette, int which, float r, float g, float b)
{
    const VideoModeEntry* entry = NTSCModes + CurrentVideoMode;
    return entry->setPaletteEntry(entry, palette, which, r, g, b);
}

int VideoModeSetRowPalette(int row, int palette)
{
    const VideoModeEntry* entry = NTSCModes + CurrentVideoMode;
    return entry->setRowPalette(entry, row, palette);
}

void VideoModeWaitFrame()
{
    // NTSC won't actually go lineNumber >= 525...
    while(!(lineNumber > 257 && lineNumber < 262) || (lineNumber > 520 && lineNumber < 525)); // Wait for VBLANK; should do something smarter
}

//----------------------------------------------------------------------------
// Text command interface

int showScanoutStats = 0;

void NTSCGenerateLineBuffers();

int doCommandTestColor(int wordCount, char **words)
{
    enum VideoModeType type = VideoModeGetType(VideoGetCurrentMode());
    
    if(type != VIDEO_MODE_PIXMAP) {

        printf("current mode is not a pixmap; use \"modes\"\n");
        printf("to list modes and \"pixmap\" to choose a pixmap mode.\n");

    } else {

        VideoPixmapInfo info;
        VideoPixmapParameters params;
        VideoModeGetInfo(VideoGetCurrentMode(), &info);
        VideoModeGetParameters(&params);
        if(info.paletteSize > 0) {
            MakePalette(0, info.paletteSize, NULL);
            for(int y = 0; y < info.height; y++) {
                rowPalette[y] = 0;
            }
        }

        ClearPixmap(0);

        // Yes, my use of rand() here is bad.

        for(int i = 0; i < 100; i++) {
            int cx = 10 + rand() % (info.width - 20);
            int cy = 10 + rand() % (info.height - 20);
            int cr = 5 + rand() % 30;
            int c;
            if(info.paletteSize == -1) {
                if(info.pixelFormat == GRAY_2BIT) {
                    c = rand() % 4; 
                } else {
                    c = rand() % 2; 
                }
            } else {
                c = rand() % info.paletteSize;
            }
            DrawFilledCircle(cx, cy, cr, c, info.aspectX, info.aspectY);

            int x0 = 10 + rand() % (info.width - 20);
            int y0 = 10 + rand() % (info.height - 20);
            int x1 = 10 + rand() % (info.width - 20);
            int y1 = 10 + rand() % (info.height - 20);
            DrawLine(x0, y0, x1, y1, c);
        }
    }

    return COMMAND_CONTINUE;
}

static void RegisterCommandTestColor(void) __attribute__((constructor));
static void RegisterCommandTestColor(void)
{
    RegisterApp("testcolor", 1, doCommandTestColor, "",
        "test color modes"
        );
}


int doCommandVideoModes(int wordCount, char **words)
{
    for(int i = 0; i < VideoGetModeCount(); i++) {
        printf("Mode %d\n", i);
        enum VideoModeType type = VideoModeGetType(i);
        switch(type) {
            case VIDEO_MODE_PIXMAP: {
                VideoPixmapInfo info;
                VideoModeGetInfo(i, &info);
                printf("    pixmap, %d by %d\n", info.width, info.height);
                printf("    is %s", info.color ? "color" : "monochrome or grayscale");
                if(info.paletteSize > 0) {
                    printf(", %d palette entries", info.paletteSize);
                }
                printf("\n");
                printf("    %s\n", info.overscan ? "overscan" : "underscan");
                break;
            }
            case VIDEO_MODE_TEXTPORT: {
                VideoTextportInfo info;
                VideoModeGetInfo(i, &info);
                printf("    text, %d by %d\n", info.width, info.height);
                switch(info.attributes) {
                    case TEXT_8BIT_WHITE_ON_BLACK: printf("    8-bit, white on black\n"); break;
                    case TEXT_8BIT_BLACK_ON_WHITE: printf("    8-bit, black on white\n"); break;
                    case TEXT_16BIT_8_3_3_2_RICH: printf("    16-bit, rich formatting\n"); break;
                }
                break;
            }
            case VIDEO_MODE_WOZ: {
                printf("    Woz-type\n");
                break;
            }
            case VIDEO_MODE_TMS9918A: {
                printf("    TMS9918A-type\n");
                break;
            }
            case VIDEO_MODE_SEGMENTS: {
                printf("    real-time segment-renderer-type\n");
                break;
            }
            case VIDEO_MODE_DCT: {
                printf("    DCT-type\n");
                break;
            }
            case VIDEO_MODE_WOLFENSTEIN: {
                printf("    Wolfenstein-type\n");
                break;
            }
            default: {
                printf("    unknown mode type %08X\n", type);
            }
        }
    }
    return COMMAND_CONTINUE;
}

int doCommandTextMode(int wordCount, char **words)
{
    int which = strtol(words[1], NULL, 0);

    if((which < 0) || (which >= VideoGetModeCount())) {
        printf("mode %d is out of range; only %d modes (list modes with \"modes\")\n", which, VideoGetModeCount());
        return COMMAND_FAILED;
    }
    if(VideoModeGetType(which) != VIDEO_MODE_TEXTPORT) {
        printf("mode %d is not a text mode (list modes with \"modes\")\n", which);
        return COMMAND_FAILED;
    }

    TextportSetMode(which);

    return COMMAND_CONTINUE;
}

int doCommandPixmapMode(int wordCount, char **words)
{
    int which = strtol(words[1], NULL, 0);
    if((which < 0) || (which >= VideoGetModeCount())) {
        printf("mode %d is out of range; only %d modes (list modes with \"modes\")\n", which, VideoGetModeCount());
        return COMMAND_FAILED;
    }
    if(VideoModeGetType(which) != VIDEO_MODE_PIXMAP) {
        printf("mode %d is not a pixmap mode (list modes with \"modes\")\n", which);
        return COMMAND_FAILED;
    }
    VideoSetMode(which);
    /* draw a pretty into picture? */
    return COMMAND_CONTINUE;
}

int doCommandStream(int wordCount, char **words)
{
#if 0
    NTSCMode = VIDEO_PALETTIZED;

    const char *formatName = words[1];
    int start = strtol(words[2], NULL, 0);
    int end = strtol(words[3], NULL, 0);

    char formattedName[512];
    float displayTime = 0;
    float endTime = (end - start) / 30.0;
    do {
        int frameNumber = start + (int)(displayTime * 30.0);
        sprintf(formattedName, formatName, frameNumber);
        // Must have been quantized to 256 colors!
        // while(lineNumber < 224); // Wait for VBLANK-ish
        float duration;
        if(readPalettized(formattedName, &duration)) {
            printf("failed to show \"%s\"\n", formattedName); 
            break;
        }
        displayTime += duration;
    } while(displayTime < endTime);
#endif
    return COMMAND_CONTINUE;
}


int doCommandVideoTest(int wordCount, char **words)
{
    NTSCMode = NTSC_COLOR_TEST;
    return COMMAND_CONTINUE;
}

int doCommandScanoutStats(int wordCount, char **words)
{
    showScanoutStats = !showScanoutStats;
    if(!showScanoutStats) {
        debugOverlayEnabled = 0;
    }
    return COMMAND_CONTINUE;
}

int doCommandVideoText(int wordCount, char **words)
{
    gOutputDevices = gOutputDevices ^ OUTPUT_TO_TEXTPORT;
    return COMMAND_CONTINUE;
}

int doCommandShowLineEnd(int wordCount, char **words)
{
    markHandlerInSamples = !markHandlerInSamples;
    return COMMAND_CONTINUE;
}

int doCommandScanoutCycles(int wordCount, char **words)
{
    int cyclesPerLine = SystemCoreClock / 59.94 / 262;
    // XXX Use a histogram instead
    for(int i = 0; i < 525; i++) {
        printf("row %3d: %8u cycles, %lu microseconds", i, rowCyclesSpent[i],
            rowCyclesSpent[i] / (SystemCoreClock / 1000000));
        if(rowCyclesSpent[i] > cyclesPerLine) {
            printf(", overrun by %u%%\n", rowCyclesSpent[i] * 100 / cyclesPerLine - 100);
        } else { 
            printf(", %u%% remained\n", (cyclesPerLine - rowCyclesSpent[i]) * 100 / cyclesPerLine);
        }
    }
    printf("%d cyclesPerLine were available\n", cyclesPerLine);

    return COMMAND_CONTINUE;
}

int doCommandSolidFill(int wordCount, char **words)
{
    solidFillWave = strtoul(words[1], NULL, 0);
    NTSCMode = NTSC_SOLID_FILL;
    printf("solid image with %08lX word\n", solidFillWave);
    return COMMAND_CONTINUE;
}

int doCommandScopeFill(int wordCount, char **words)
{
#if 0
    NTSCMode = VIDEO_PALETTIZED;
    int degrees = strtol(words[1], NULL, 0);
    printf("vector scope image at %d degrees phase\n", degrees);
    showVectorScopeImage(degrees);
#endif
    return COMMAND_CONTINUE;
}

int doCommandTestRect(int wordCount, char **words)
{
    NTSCMode = NTSC_SCAN_TEST;
    do {
        SERIAL_poll_continue();
        unsigned char isEmpty = queue_isempty(&mon_queue.q);
        if(!isEmpty) {
            unsigned char c = queue_deq(&mon_queue.q);
            switch(c) {
                case 'l': videoScanTestLeft--; break;
                case 'L': videoScanTestLeft++; break;
                case 'r': videoScanTestRight--; break;
                case 'R': videoScanTestRight++; break;
                case 't': videoScanTestTop--; break;
                case 'T': videoScanTestTop++; break;
                case 'b': videoScanTestBottom--; break;
                case 'B': videoScanTestBottom++; break;
                case 'q': break; break;
            }
            printf("rect is %d, %d, %d, %d\n", videoScanTestLeft, videoScanTestRight, videoScanTestTop, videoScanTestBottom);
            SERIAL_flush();
        }
        delay_ms(10);
    } while(1);
    return COMMAND_CONTINUE;
}

int doCommandDumpKbdData(int wordCount, char **words)
{
    gDumpKeyboardData = !gDumpKeyboardData;
    if(gDumpKeyboardData)
        printf("Dumping keyboard data...\n");
    else
        printf("Not dumping keyboard data...\n");
    return COMMAND_CONTINUE;
}

int doCommandSDReset(int wordCount, char **words)
{
    printf("Resetting SD card...\n");

    if(!SDCARD_init()) {
        printf("Failed to start access to SD card as SPI\n");
    }
    return COMMAND_CONTINUE;
}

int doCommandLS(int wordCount, char **words)
{
    FRESULT res;
    DIR dir;
    static FILINFO fno;

    res = f_opendir(&dir, "/");                       /* Open the directory */
    if (res == FR_OK) {
        for (;;) {
            res = f_readdir(&dir, &fno);                   /* Read a directory item */
            if(res != FR_OK) {
                printf("failed to readdir - %d\n", res);
                break;
            }
            if (fno.fname[0] == 0) break;  /* Break on end of dir */
            if (fno.fattrib & AM_DIR) {                    /* It is a directory */
                printf("/%s/\n", fno.fname);
            } else {                                       /* It is a file. */
                printf("/%s\n", fno.fname);
            }
        }
        f_closedir(&dir);
    } else {
        printf("failed to f_opendir - %d\n", res);
    }
    return COMMAND_CONTINUE;
}

int doCommandTestSDSpeed(int wordCount, char **words)
{
    const int megabytes = 2;
    printf("will read %d megabyte of SD\n", megabytes);

    SERIAL_flush();

    unsigned char *sd_buffer = malloc(SD_BLOCK_SIZE);
    if(sd_buffer == NULL) {
        printf("couldn't allocate block buffer\n");
        return COMMAND_FAILED;
    }

    int then = HAL_GetTick();
    for(int i = 0; i < megabytes * 1024 * 1024 / SD_BLOCK_SIZE; i++)
        SDCARD_readblock(i, sd_buffer);
    int now = HAL_GetTick();

    int kilobytes = megabytes * 1024;
    int millis = now - then;
    int kb_per_second = kilobytes * 1000 / millis;

    printf("done, %d KB per second\n", kb_per_second);

    free(sd_buffer);

    return COMMAND_CONTINUE;
}

int doCommandReadBlock(int wordCount, char **words)
{
    int n = strtol(words[1], NULL, 0);
    unsigned char *sd_buffer = malloc(SD_BLOCK_SIZE);
    if(sd_buffer == NULL) {
        printf("couldn't allocate block buffer\n");
        return COMMAND_FAILED;
    }
    if(SDCARD_readblock(n, sd_buffer)) {
        dump_buffer_hex(4, sd_buffer, sizeof(sd_buffer));
    }
    free(sd_buffer);
    return COMMAND_CONTINUE;
}

int doCommandFlashInfoLED(int wordCount, char **words)
{
    for(int i = 0; i < 8; i++) {
        LED_set_info(1);
        delay_ms(125);
        LED_set_info(0);
        delay_ms(125);
    }
    return COMMAND_CONTINUE;
}

int doCommandPanic(int wordCount, char **words)
{
    printf("panicking now\n");
    panic();
    return COMMAND_CONTINUE; /* notreached */
}

int doCommandShowVersion(int wordCount, char **words)
{
    printf("%s\n", IOBOARD_FIRMWARE_VERSION_STRING);
    return COMMAND_CONTINUE;
}

int doCommandSetDebugLevel(int wordCount, char **words)
{
    gDebugLevel = strtol(words[1], NULL, 0);
    printf("Debug level set to %d\n", gDebugLevel);
    return COMMAND_CONTINUE;
}

int doHalt(int wordCount, char **words)
{
    while(1) {};
}

#define MAX_COMMANDS 50

Command commands[MAX_COMMANDS];
int commandsCount = 0;

extern caddr_t _sbrk(int incr);
extern void* sbrk(int incr);

int RegisterApp(const char* name, int minWords, ProcessCommandFunc go, const char *form, const char *help)
{
    if(commandsCount >= MAX_COMMANDS) {
        printf("maximum command count reached!\n");
        return COMMAND_ADD_FAILED;
    }
    Command *newcmd = commands + commandsCount;
    commandsCount++;

    newcmd->name = name;
    newcmd->minWords = minWords;
    newcmd->go = go;
    // Need to close all open files,
    newcmd->form = form;
    newcmd->help = help;

    return 0;
}

static void RegisterAllApplets() __attribute__((constructor));
static void RegisterAllApplets()
{
    RegisterApp( "modes", 1, doCommandVideoModes, "",
        "list video modes"
    );
    RegisterApp( "pixmap", 2, doCommandPixmapMode, "mode",
        "set pixmap mode"
    );
    RegisterApp( "text", 2, doCommandTextMode, "mode",
        "set text mode"
    );
    RegisterApp( "rect", 1, doCommandTestRect, "",
        "run interactive over/underscan test"
    );
#if 0
    RegisterApp( "stream", 4, doCommandStream, "name M N",
        "stream images from templated name (e.g. 'frame%05d') from number M to N"
    );
#endif
    RegisterApp( "videotest", 1, doCommandVideoTest, "",
        "switch to video test mode"
    );
    RegisterApp( "stats", 1, doCommandScanoutStats, "",
        "toggle viewing of scanout error statistics"
    );
    RegisterApp( "showend", 1, doCommandShowLineEnd, "",
        "put out a marker in the DAC at line processing end"
    );
    RegisterApp( "text", 1, doCommandVideoText, "",
        "toggle sending text to video"
    );
    RegisterApp( "rowcycles", 1, doCommandScanoutCycles, "",
        "print time spent in each row operation"
    );
    RegisterApp( "solid", 2, doCommandSolidFill, "fillword",
        "fill video with specified long int"
    );
    RegisterApp( "dumpkbd", 1, doCommandDumpKbdData, "",
        "dump keyboard data"
    );
    RegisterApp( "sdreset", 1, doCommandSDReset, "",
        "reset SD card"
    );
    RegisterApp( "sdspeed", 1, doCommandTestSDSpeed, "",
        "test SD read speed"
    );
    RegisterApp( "ls", 1, doCommandLS, "",
        "list files on SD"
    );
    RegisterApp( "read", 2, doCommandReadBlock, "N",
        "read and dump out SD block N"
    );
    RegisterApp( "flashinfo", 1, doCommandFlashInfoLED, "",
        "flash the info LED"
    );
    RegisterApp( "panic", 1, doCommandPanic, "",
        "panic"
    );
    RegisterApp( "version", 1, doCommandShowVersion, "",
        "display build version string"
    );
    RegisterApp( "debug", 2, doCommandSetDebugLevel, "N",
        "set debugging level to N"
    );
    RegisterApp( "halt", 1, doHalt, "", "while(1){}");
}

void usage()
{
    int maxNeeded = 0;
    for(int which = 0; which < commandsCount; which++) {
        Command *cmd = commands + which;
        int needed = strlen(cmd->name) + 1 + strlen(cmd->form);
        maxNeeded = (needed > maxNeeded) ? needed : maxNeeded;
    }
    for(int which = 0; which < commandsCount; which++) {
        Command *cmd = commands + which;
        printf("%s %s", cmd->name, cmd->form);
        // XXX some day be smarter about word wrap etc
        printf("%*s - %s\n", maxNeeded - strlen(cmd->name) - 1 - strlen(cmd->form), "", cmd->help);
    }
}

#define CommandWordsMax 10

int processCommandLine(char *line)
{
    static char *words[CommandWordsMax];

    int wordsCount = SplitString(line, words, CommandWordsMax);

    if(wordsCount == 0) {
        return COMMAND_CONTINUE;
    }

    if(wordsCount == CommandWordsMax) {
        printf("(warning, parsing command filled word storage)\n");
        printf("(arguments %d and after were combined)\n", CommandWordsMax);
    }

    int found = 0;
    for(int which = 0; which < commandsCount; which++) {
        Command *cmd = commands + which;
        if(strcmp(words[0], cmd->name) == 0) {
            found = 1;
            if(wordsCount < cmd->minWords) {
                printf("expected at least %d words for command \"%s\", parsed only %d\n", cmd->minWords, cmd->name, wordsCount);
                usage();
            } else {

#if 0
                // save memory allocation state to restore later
                extern unsigned int __malloc_sbrk_base;
                extern unsigned int __malloc_trim_threshold;
                extern char *__malloc_av_[0x408];
                static unsigned int save__malloc_sbrk_base;
                static unsigned int save__malloc_trim_threshold;
                static unsigned char save__malloc_av_[0x408];
                void* oldbrk = sbrk(0);
                printf("previous brk = %p\n", oldbrk);
                save__malloc_sbrk_base = __malloc_sbrk_base;
                save__malloc_trim_threshold = __malloc_trim_threshold;
                memcpy(save__malloc_av_, __malloc_av_, sizeof(save__malloc_av_));
                printf("old __malloc_sbrk_base: %08X\n", *(unsigned int*) save__malloc_sbrk_base);
                printf("old __malloc_trim_threshold: %08X\n", *(unsigned int*) save__malloc_trim_threshold);
                printf("old __malloc__av_:\n");
                printf("    ");
                for(int i = 0; i < 102; i++) {
                     printf(" %08X", *(unsigned int*)(save__malloc_av_ + i * 4));
                     if((i % 8 == 0) && (i != 101)) {
                         printf("\n    ");
                     }
                }
                printf("\n");
                SERIAL_flush();
#endif

                // Need to initialize app BSS somehow - need mini-loader
                int result = cmd->go(wordsCount, words);

#if 0
                // reset memory allocation bss
                extern unsigned char __malloc_current_mallinfo[0x28];
                extern unsigned int __malloc_max_sbrked_mem;
                extern unsigned int __malloc_max_total_mem;
                extern unsigned int __malloc_top_pad;
                memset(__malloc_current_mallinfo, 0, 0x28);
                __malloc_max_sbrked_mem = 0;
                __malloc_max_total_mem = 0;
                __malloc_top_pad = 0;
                // restore memory allocation data
                __malloc_sbrk_base = save__malloc_sbrk_base;
                __malloc_trim_threshold = save__malloc_trim_threshold;
                memcpy(__malloc_av_, save__malloc_av_, sizeof(save__malloc_av_));
                printf("new brk = %p\n", sbrk(0));
                int brkdiff = sbrk(0) - oldbrk;
                memset(oldbrk, 0, brkdiff);
                sbrk(-brkdiff);
                printf("reset brk = %p\n", sbrk(0));
#endif

                return result;
            }
        }
    }

    if(!found) {
        printf("Unknown command \"%s\"\n", words[0]);
        usage();
    }
    return COMMAND_CONTINUE; // XXX COMMAND_UNKNOWN?
}

void process_local_key(unsigned char c)
{
    // XXX make this table driven, break into lots smaller functions
    if(c == '\r' || c == '\n') {
        putchar('\n');
        gMonitorCommandBuffer[gMonitorCommandBufferLength] = 0;

        processCommandLine(gMonitorCommandBuffer);
        printf("* ");
        gMonitorCommandBufferLength = 0;

    } else {

        if(c == 127 || c == '\b') {
            if(gMonitorCommandBufferLength > 0) {
                putchar('\b');
                putchar(' ');
                putchar('\b');
                gMonitorCommandBufferLength--;
            } else {
                bell();
            }
        } else {
            if(gMonitorCommandBufferLength < sizeof(gMonitorCommandBuffer) - 1) {
                putchar(c);
                gMonitorCommandBuffer[gMonitorCommandBufferLength++] = c;
            } else {
                bell();
            }
        }
    // TODO - upload data, write block
    }
}

uint32_t /* SECTION_CCMRAM */ vectorTable[100] __attribute__ ((aligned (512)));

extern int KBDInterrupts;
extern int UARTInterrupts;

FATFS gFATVolume;

int main()
{
    HAL_Init();

#if 0
    uint32_t* oldVectorTable = (uint32_t*)SCB->VTOR;
    memcpy(vectorTable, oldVectorTable, sizeof(vectorTable));
    SCB->VTOR = (uint32_t)vectorTable; // This didn't help glitching, and can't be in *data* CCM RAM
#endif

    SystemClock_Config(); 

    LED_init();
    LED_beat_heart();

    MON_init();
    console_queue_init();
    LED_beat_heart();

    setbuf(stdout, NULL);

    SERIAL_init(); // transmit and receive but global interrupts disabled
    LED_beat_heart();

    printf("\n\nRocinante firmware, %s\n", IOBOARD_FIRMWARE_VERSION_STRING);
    printf("System core clock: %lu Hz, %lu MHz\n", SystemCoreClock, SystemCoreClock / 1000000);

    float clock = 14.318180;
    NTSCCalculateParameters(clock);

    printf("calculated NTSCLineClocks = %d\n", NTSCLineClocks);
    printf("calculated NTSCHSyncClocks = %d\n", NTSCHSyncClocks);
    printf("calculated NTSCFrontPorchClocks = %d\n", NTSCFrontPorchClocks);
    printf("calculated NTSCBackPorchClocks = %d\n", NTSCBackPorchClocks);
    printf("calculated NTSCEqPulseClocks = %d\n", NTSCEqPulseClocks);
    printf("calculated NTSCVSyncClocks = %d\n", NTSCVSyncClocks);
    printf("RCC->DCKCFGR1 = %08X\n", RCC->DCKCFGR1);

    LED_beat_heart();
    SERIAL_flush();

    if(0){ 
        GPIO_InitTypeDef  GPIO_InitStruct;

        GPIO_InitStruct.Pin = GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
        GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
        GPIO_InitStruct.Pull = GPIO_PULLDOWN;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
        GPIO_InitStruct.Pin = GPIO_PIN_14;
        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
        GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
        GPIO_InitStruct.Pull = GPIO_PULLDOWN;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        HAL_GPIO_Init(GPIOD, &GPIO_InitStruct); 
        int a;
        while(1) {
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, (a & 0x01) ? 1 : 0);
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, (a & 0x02) ? 1 : 0);
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, (a & 0x04) ? 1 : 0);
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, (a & 0x08) ? 1 : 0);
            delay_ms(500);
            a ++;
        }
    }

    SPI_config_for_sd();
    LED_beat_heart();

    if(!SDCARD_init()) {
        printf("Failed to start access to SD card SPI!!\n");
        LED_beat_heart();
        SERIAL_flush();
    } else  {
        printf("Opened SD Card\n");
        LED_beat_heart();
        SERIAL_flush();

        FRESULT result = f_mount(&gFATVolume, "0:", 1);
        if(result != FR_OK) {
            logprintf(DEBUG_ERRORS, "ERROR: FATFS mount result is %d\n", result);
            panic();
        } else {
            printf("Mounted FATFS from SD card successfully.\n");
        }
        LED_beat_heart();
        SERIAL_flush();
    }

#ifdef USE_PS2KBD
    KBD_init();
    LED_beat_heart();
#endif

#ifdef USE_AUDIO
    // AUDIO
    for(int i = 0; i < sizeof(audioBuffer); i++) {
        audioBuffer[i] = 128;
    }
    {
        // Set PA4 to ANALOG
        GPIO_InitTypeDef  GPIO_InitStruct;

        GPIO_InitStruct.Pin = GPIO_PIN_4;
        GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
    }
    DAC->CR |= DAC_CR_EN1;
    DAC->CR |= DAC_CR_BOFF1;
#endif

    NTSCGenerateLineBuffers();
    NTSCFillRowBuffer(0, 0, row0);
    memset(row0, 0x10, sizeof(row0));
    memset(row1, 0xF0, sizeof(row1));

    float colorBurstInCoreClocks = SystemCoreClock / 14318180.0;
    uint32_t DMACountAt14MHz = (colorBurstInCoreClocks + .5);
    // printf("DMACountAt14MHz = %lu, expected %d\n", DMACountAt14MHz, clockConfigs[whichConfig].DMA_TIM_CLOCKS);
    DMACountAt14MHz = clockConfigs[whichConfig].DMA_TIM_CLOCKS; // (colorBurstInCoreClocks + .5);

    DMAStartScanout(DMACountAt14MHz);

    // Wait for a click to progress to the next clock config
    { 
        GPIO_InitTypeDef  GPIO_InitStruct;

        GPIO_InitStruct.Pin = GPIO_PIN_13;
        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = GPIO_PULLDOWN;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
    }
    delay_ms(50);

    // If button is pushed down, enter clock config inspector
    if(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13)) {

        debugOverlayEnabled = 1;
        memset(debugDisplay, 0, debugDisplayWidth * debugDisplayHeight);

        int debugLine = 0;
        sprintf(debugDisplay[debugLine++], "Release button");
        sprintf(debugDisplay[debugLine++], "For ClockConfig");
        sprintf(debugDisplay[debugLine++], "Inspector");

        delay_ms(50);
        while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13));
        delay_ms(50);

        int counter = 0; 
        for(;;) {

            whichConfig = counter;

            DMAStopScanout();

            // Probably will break UART and SD and GPIOs:
            DeInitRCCAndPLL();
            SystemClock_Config();

            // Set up LED that toggles for every mode we look at
            GPIO_InitTypeDef  GPIO_InitStruct = {0};
            GPIO_InitStruct.Pull = GPIO_NOPULL;
            GPIO_InitStruct.Pin = 0x100;
            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
            GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
            HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
            GPIOC->ODR = GPIOC->ODR & ~0x100;

            if(counter % 2 != 0) {
                GPIOC->ODR |= 0x100; // PC8
            }

            float colorBurstInCoreClocks = SystemCoreClock / 14318180.0;
            // need main clock as close as possible to @ 171.816
            uint32_t DMACountAt14MHz = (colorBurstInCoreClocks + .5);
            // printf("DMACountAt14MHz = %lu, expected %d\n", DMACountAt14MHz, clockConfigs[whichConfig].DMA_TIM_CLOCKS);
            DMACountAt14MHz = clockConfigs[whichConfig].DMA_TIM_CLOCKS; // (colorBurstInCoreClocks + .5);

            DMAStartScanout(DMACountAt14MHz);

            debugOverlayEnabled = 1;
            memset(debugDisplay, 0, debugDisplayWidth * debugDisplayHeight);

            int debugLine = 0;
            sprintf(debugDisplay[debugLine++], "Number %d", whichConfig);
            sprintf(debugDisplay[debugLine++], "PLL_M %lu", clockConfigs[whichConfig].PLL_M);
            sprintf(debugDisplay[debugLine++], "PLL_N %lu", clockConfigs[whichConfig].PLL_N);
            sprintf(debugDisplay[debugLine++], "PLL_P %lu", clockConfigs[whichConfig].PLL_P);
            sprintf(debugDisplay[debugLine++], "(DMA_TIM_CLOCKS %lu)", clockConfigs[whichConfig].DMA_TIM_CLOCKS);
            uint32_t at14MHz = (colorBurstInCoreClocks + .5);
            sprintf(debugDisplay[debugLine++], "calcd DMA BEATS %lu", at14MHz);
            sprintf(debugDisplay[debugLine++], "CPU clock: %d", (int)(clockConfigs[whichConfig].CPUFreq));
            sprintf(debugDisplay[debugLine++], "SCClock: %lu", SystemCoreClock);
            int clockConfigsWhole = clockConfigs[whichConfig].colorburstClock;
            sprintf(debugDisplay[debugLine++], "color %d.%03d", clockConfigsWhole, (int)((clockConfigs[whichConfig].colorburstClock - clockConfigsWhole) * 100000.0f));

            // Wait for a click to progress to the next clock config
            { 
                GPIO_InitTypeDef  GPIO_InitStruct;

                GPIO_InitStruct.Pin = GPIO_PIN_13;
                GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
                GPIO_InitStruct.Pull = GPIO_PULLDOWN;
                GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
                HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
            }
            while(!HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13)) {
                delay_ms(50);
            }
            delay_ms(250);

            counter++;
            if(counter >= clockConfigCount) {
                memset(debugDisplay, 0, debugDisplayWidth * debugDisplayHeight);
                int debugLine = 0;
                sprintf(debugDisplay[debugLine++], "END OF CONFIGS");
                sprintf(debugDisplay[debugLine++], "HOORAY!");
                break;
            }
        }
        while(1);
    }

    // Kick into first text mode if possible
    int chosen = -1;
    for(int which = 0; (chosen == -1) && (which < VideoGetModeCount()); which++) {
        if(VideoModeGetType(which) == VIDEO_MODE_TEXTPORT) {
            chosen = which;
        }
    }
    if(chosen == -1) {
        printf("Couldn't find a text mode, didn't set up screen output or VT102\n");
    } else {
        TextportSetMode(chosen);
        NTSCMode = NTSC_USE_VIDEO_MODE;
        gOutputDevices = gOutputDevices ^ OUTPUT_TO_TEXTPORT;
    }

    printf("* ");
    SERIAL_flush();

    for(;;) {

#ifdef USE_NTSC
        // Should be in VBlank callback so is continuously updated
        if(showScanoutStats) {
            debugOverlayEnabled = 1;
            uint32_t currentFrame = frameNumber;
            while(currentFrame == frameNumber); // Wait for VBLANK
            memset(debugDisplay, 0, debugDisplayWidth * debugDisplayHeight);
            sprintf(debugDisplay[debugDisplayHeight - 4], "UART %d", UARTInterrupts);
            sprintf(debugDisplay[debugDisplayHeight - 3], "KBD %d", KBDInterrupts);
            sprintf(debugDisplay[debugDisplayHeight - 2], "FIFO unders %lu", DMAFIFOUnderruns);
            sprintf(debugDisplay[debugDisplayHeight - 1], "DMA errors %lu", DMATransferErrors);
        }
#endif
        int key;

        SERIAL_try_to_transmit_buffers();
        // LED_beat_heart();

        SERIAL_poll_continue();

        process_monitor_queue();

#ifdef USE_PS2KBD
        key = KBD_process_queue(gDumpKeyboardData);
        if(key >= 0) {
            disable_interrupts();
            // console_enqueue_key_unsafe(key);
            monitor_enqueue_key_unsafe(key);
            enable_interrupts();
        }
#endif

        check_exceptional_conditions();
    }

    // should not reach
    panic();
}
