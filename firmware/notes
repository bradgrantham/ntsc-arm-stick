Go back and make sure
    VideoSetBackgroundColor - should be only for topmost window, and black if not set
    is "Video" the right name for video/window functions?
    be consistent about:
        window position (int16_t)
        window size (uint16_t but > 32767 invalid so can operate on int16_t)
        screen width and height (uint16_t but > 32767 invalid so can operate on int16_t)
    be consistent with:
        range, span, segment,
        row, pixel, column, x, y,
        length vs count
    be consistent with window, windowIndex, windowID : windowID?  Make a typedef int "Window"?  But Window is already the struct for windowing
    are VideoGetModeCount() and VideoModeGetType() inconsistent? - consider, make consistent, record policy here
    convert this doc to Markdown
    be consistent about global variable names - g${Name}?  ${Name}?  Rosa${Name}?  Rosa${Facility}${Name}?

to do
    interactive window test
        implement pointer draw
            pointer drawing in...?  concrete video subsystem
                entrypoints passed through to concrete subsystem
        implement rubberband
        implement some key processing (at least Meta)
            test what the keycodes are in USB - do they match GLFW?
        Meta + click = drag
            click in window: gMovingWindow = windowID
            if(gMovingWindow != NO_WINDOW) { motion : attemptConfiguration, move rubberband on success; release : }
    fix bug in Pixmap moveAllocation? - somehow spans missed?
    fix seg fault if showimage chooses 2x2 scale pixmap
    should reallocate/moveAllocation take a vector of Event to fill in?
    window resize
        implement border
        implement resize
    fix NTSC color interpretation
    fix NTSC window moves to multiples of 4 samples?
    fullscreen
    hosted: 912 samples...?
    hosted: get phase with row offset based on ROW_SAMPLES
    systemwide named variables & config program

----------------------------

Stated explicitly:
    Make silicon do as much as possible - as few and as cheap external components as possible
        So avoid external DAC (expensive), use weighted resistor DAC
            unless VGA and NTSC look terrible, then upgrade to real DACs.
            unless real DAC would be cheaper than resistor DAC...
        But use external crystal if necessary to get color response from 1084 (and other monitors)
        Settle on STM32H743IIT6 for now
    App and Driver API should be the one you're most comfortable with (because no one else will use it!)
        But write something nice enough that someone else *could* use it.
    C++17 interfaces and code internally
    Windowing, then Processes (and pipes? signals?), then Loader
        Or does it really help to have Loader first, so I can have multiple apps at one time?
        Initially apps can have no globals, that should work for multiple apps with no loader...

-----------------------------

to plumb through fullscreen API, add a Woz fullscreen text mode and do playback of text memory writes from apple2e

Modularizing video (best reference is source code for apps!)
    minifying windows ...?
        fillRow that outputs RGB8 and allowed to be non-optimized?  Then shrink with antialiasing and show... where?
    Do I need a generalized race-the-beam drawing library for window decorations, text, min/max/close icons
    Window coverage, range, span sample diagram: https://docs.google.com/drawings/d/1fAEjk5LkpoVFAkQtjVpDIjrKxcilrsKm9ytVupJzXDs/edit
    App Abstraction 
        optionally VideoSetBackgroundColor(float r, float g, float b); - this is background when window is FRONT, otherwise black
        VideoGetModeCount() to get number of modes, then loops through them
            VideoSubsystem has vector of VideoModeDriver*
        Status VideoModeGetType(int n, VideoModeType &type) to get mode
            VideoSubsystem calls VideoModeDriver->getType();
        Status VideoModeGetInfo(int n, ModeInformation* info, size) to determine if it meets needs (or skip this)
        Status = WindowCreate(mode, "title", parameters, &window)
            // enqueues WINDOWED or FULLSCREEN
            // enqueues FRONT
            // enqueues RESIZE
            // enqueues REDRAW
        while((status = EventPoll(&event)) {
            switch(event.type) (
                ...
            }
        }

    Make ::fillRow be part of the driver specific to a subsystem?
    fillRow
        It's probably important to enable writing by uint32_t into rowBuffer for optimization
            Do I hand off an aligned pointer and a pad?
            Or do I hand off the current pointer and make fillRow pad to the next uint32_t?
        fillRow is kind of too-flexible.  I don't really want to walk the Range for every span...
            fillStartRange(uint16_t rowWithinWindow) called on or before the first window row
            fillEndScanline(uint16_t rowWithinWindow) called to finish a scanline (increment scanline pointer, reset span pointer)
            fillNextSpan() called to draw the next span
    fillRect
        ScanlineInfo -> Scanline
        I had assumed a Scanline for entire height of window.
            If a window wants to keep its own backing store, I think it probably wants to receive an entire drawRect
                And if a window wants to keep its own backing store, I imagine it will also want to say whether the Windowing system should send a partial REDRAW on surface exposure or whether it should send a complete REDRAW only on initial creation and on RESIZE
                Maybe on reallocate?
                This means the driver needs to know the window's complete dimensions
                pass width and height into reallocate, driver can store them in root allocation or not
    Need pixmap mode drivers to be able to express a pixel resolution (pixmap pixel to screen pixel)
        want a way to request highest-res mode if desired (old MAXRES mode)
        But all size specifications at the moment are in screen pixels.
            App will want to specify a certain size pixmap sometimes.  But that's specific to Pixmap.
            Pixmap could have a convenience function taking requested size and returning the WindowCreate attributes to request that size on-screen...
    Video Subsystem keeps track of window location, size, Z order, whether it's fullscreen, and its mode
    re-allocation events: window stacking order changed, window moved, window resized, window fullscreened or windowed
    Explicit mouse query?
        void MouseGetPosition(int *x, int *y);
        void MouseGetButtonsPressed(int *b1, int *b2, int *b2); // 0 = not pressed, 1 = pressed
    every window (only front window?) has a 2 or 4-pixel border?
    need a video mode which is a solid color for background
    Some video game modes (TMS9918A, Woz, TIA) require full-screen.
        Debug overlay says "Game mode" if ALT-space pressed or some such?
        Wolfenstein, too?  Not clear.
    all video modes can be windowed, but front can be fullscreen
        stop offering out pointers to memory, use Set-style functions for all content
        is fullscreen just a window that's full-screen size?  Or does it mean something else?
            wouldn't have border in fullscreen
            all memory can be dedicated to fullscreen and minimal book-keeping used
    Because NTSC has BW and Color modes, FRONT window dictates in NTSC whether Colorburst is added
    Win+Up to fullscreen FRONT window, Win+Down to return to previous size
    Click on not-FRONT window brings to FRONT
    Click on FRONT window is passed to app owning FRONT
    non-FRONT window doesn't get mouse moves?
    Click on border resizes (just outline is shown until button release)
    Does CB need to rotate phase 180 degrees each line?
Need generic DMA/DAC facility (or do I is DAC/DMA used for anything but NTSC or VGA?)
Could probably pull off 304x192 r5g6b5 framebuffer within 128K, or 384x256 r3g3b2 within 128K (would dither)
    But why bother with r3g3b2?  Just make a 256-LUT?  Save memory, make conversion explicit?
Let's say maximum resolution, 704x460; can get 2 bits per pixel in that mode in roughly 112KB.
Let's say 1 byte per pixel. can easily do 384 * 230 in that mode in roughly 112KB.
640 * 384 is a good underscan mode
704 * 460 is a good overscan mode
Close on segmented framebuffer
    textured and solid triangles, trapezoids, and segments
    need a way to merge or continue runs to reduce memory usage
    teapot with Enable(CULLFACE):
        max 75 segments in one row
        max 8756 segments in frame
        max 41976 trapezoids per frame
    polytope256 with Enable(CULLFACE):
        max 62 segments in one row
        max 11426 segments in frame
        max 64728 trapezoids
Measured MCO/5 as HSE at 4.00086MHz on freq counter, so 20MHz crystal on protoboard is giving me 20.00430 Mhz
Move Wolf to palette-RGB-style textures (reduce bandwidth to make up lookup & process cost?)
honor aspect ratio in "show"
Some things to improve in "show"
    fix skipped lines in "hosted" - img lower resolution than framebuffer
    antialias
Make circle renderer find pixel center coordinates to see if the weird jumpiness is being caused by integer snapping - can't expect decent lit or textured rendering if the coordinates are going to jump around for some reason
Some things to improve living
    textport should be virtual and overlaid on screen in text mode and preserved for returning to text mode
        so then textport output would ALWAYS work and be recorded, and switching back to text would restore the old viewport.
        40 vs 80?  - just always 80?  (Could maybe get to 106x60 chars with 5x7 wide at 480p)
        make a scrollback buffer (what are the keyboard controls to scroll back?)
        3 pages of 80x24 = 5760 bytes, need to keep in RAM somewhere
    Factor out shell
        tab should autocomplete at CLI
            tab in first completes commands
            tab in second et al completes filenames
    frame stats should be a histogram
        get TIM frequency nailed down
    There really should be a non-interlaced video mode
DCT video mode - make it so JPG blocks can be the source of the video scanout
MP3 player - target something simple and straightforward, like 128, 160, and 256 constant bitrate joint-stereo.
hosted
    No separate console access, e.g. serial port; operate like standalone machine
    CLI/apps in other thread
        queues for output chars...?
        video and audio calls take a lock
        video scanout happens 30 Hz and also takes the lock
Video API notes
    ** part of the *novelty* of the project is that video is generated at a higher resolution than RAM allows. **
            e.g. very small palettes - 1, 2, 4 bit; RLE; DCT; specialized renderer (e.g. Wolfenstein, spin)
    NTSC output is by necessity "waves" (DAC samples represent NTSC waveform at 14.31818 MHZ)
        Probably not much point in having R8G8B8 at 912 pixels per row - can't be represented
        So need to filter at least chroma down to 3.58MHz - Gaussian of 5 samples?  Could do box filter for start
            yiq can range from 
        Individual VideoModes could filter, or just the ones I care about could filter
        SET_AND_INCREMENT_WAVE(y, i, q)
    HDMI can be whatever as long as I have 3 bytes of RGB to look up in a table
setup a software interrupt for VBlank processing (e.g. update scanout stats, audio goop) and trigger it from row=262 and row = 525 -> event interrupt?
help and other output should be paged -
    have a special mode in non-VT102 mode?  Start Paging / Stop Paging?
    OutputSetPaging(int paging)
Move Audio goop to another .c
Add some things to shell
    make this look like bash or zsh
    Can the commands below be separate apps?
    startup.sh # run from disk, quit scripting on blue button
    # run from a file
        will recursion work the way you've set it up?
    # parse between "" as one word
    # break commands on ";" outside ""
    # ignore everything after '#' outside ""
    sleep floatseconds # easy app
    # variables - "$var"?
    menu var menufile # show a menu, return the option chosen in var - app
    getchar [var] # get a single character - needs to be part of shell
    read [var] # get everything up to ENTER - needs to be part of shell
    echo everything afterwards is echoed # easy - app
    # pixmap only :
        make these part of BASIC or some other thing? windowed graphics scripting?
        palette N r g b
        circle N x y r
        line N x0 y0 x1 y1
        clear N
    # expressions
    for var = A to B [step C] ; ... ; end # part of shell
    for var in A B C D E F G ; ... ; end # part of shell
EVERYTHING should return 0 on success or non-zero error or void if it can't fail
audio
    22050Hz?  11025Hz?  8000Hz?
    write audio sample immediately on entry to line ISR?  Then calculate next one right after that, then do video calculation?
        Then audio resampling would happen at the line rate for whatever video mode is current...
    Do DMA at 22050 from double-buffered 512-byte buffers?  Could conflict with video but should be able to set priority lower.
    stereo audio output?
    audio modes:
        MIXED: add a finite-length U8 with arbitrary sample rate to the stream, audio processing will add up all active ones
        DIRECT: app callback to fill a buffer at a rate given to the callback
    does there need to be a mix in the DIRECT mode for things like beep, etc?
vile sucks, figure it out or replace it; issues:
    #dd doesn't work
    O and o behave weirdly
    0 does not go to the beginning of the line
    a and then enter does not scroll down
    #G uses line numbers off by one - is this termios?
VT102 handling (in combination with vile) doesn't handle inserting a line?
Should debug overlay XOR or just have black background?
    find pixel under and set white or black based on that?
Get DB9 joystick working
    uint32_t InputGetJoystickDir(int whichJoy) // flags or'd ; JOYSTICK_LEFT, etc
    uint32_t InputGetJoystickButton(int whichJoy) // flags or'd ; JOYSTICK_BUTTON0, JOYSTICK_BUTTON1, etc
    get Coleco joystick working
Raycaster game!
    monsters come after you, can be shot, inflict damage within certain range
    need sprites for powerups, monsters other goop
    gun
    bottom row shows health, points
    health powerups?
    put texture on ceiling and floor
"Apps"
    Threading? (multitasking, task switching)
        all system functions have to be thread-safe...  Wrap locks around them
        then need scheduler
        if multiple apps can run simultaneously, then pipes would work
    compile all apps with TinyCC or other small compiler
        (can g++ run within 16MB?)
        run as THUMB in emulation in hosted
    System APIs that Apps can call
        OS/stdlib calls
            read/write
            malloc, free, etc
            fopen, fclose, etc
        video mode and config (NTSC vs VGA handled by hard board switch)
        serial port control
        register vblank handler
        get time and sleep
        audio mode and config
        get keyboard input
        read DB9 joystick
        layered facilities
            textport
            VT102 terminal processing (on textport)
                essentially just init() and putchar()
            graphics routines
    terminal
    Wolfenstein
    3D viewer
    BASIC
    movie player... ? Targeted to full-screen 8-bit pixmap?  palette per frame?
    CP/M emulation
    Colecovision
    Apple2e
    WeFAX decoder
Channel F emulator, 9pin header adapters (bake into controller for Bart)
    need 16 pins for two controllers!
BASIC
    just implement 80x24 text mode for now
    window N # set video mode N
    lut c, r, g, b # calculate lut entry c for int r, g, b
    plot x, y, c    # plot pixel x, y with lut c
    line x0, y0, x1, y1, c # plot line
    clear c # clear screen to LUT color
    text N # text mode
    split {0,1} # split screen graphics and text (dependent on the modes?)
    handle a bunch of old BASIC programs like STARTREK, WUMPUS, ...?
    implement lunar lander
    Life: https://www.atariarchives.org/basicgames/showpage.php?page=100
        https://github.com/rricharz/R65/blob/master/Basic/life.bas
    Lunar Lander: https://www.atariarchives.org/basicgames/showpage.php?page=106
        http://vintage-basic.net/bcg/lunar.bas
    Sine Wave: https://www.atariarchives.org/basicgames/showpage.php?page=146
        http://www.vintage-basic.net/bcg/sinewave.bas
    Super Star Trek: https://www.atariarchives.org/basicgames/showpage.php?page=157
    3D Plot: https://www.atariarchives.org/basicgames/showpage.php?page=167
        http://vintage-basic.net/bcg/3dplot.bas

4/13
    On a hunch that maybe AHB doesn't do uchar writes directly and
      instead fetched a long, masked, or'd, and wrote a long, I tried
      doing word writes to GPIOC->ODR from DMA.  This would
      have been very inconvenient (altering ALL of GPIOC at once) but
      also would have meant using much more memory (a uint32_t per
      sample even though only 8 bits are used).  It didn't help, and
      in fact seemed worse.  Color didn't lock, jitter seemed as
      bad as uchar, and fillRowBuffer took MUCH longer (like 50% of the ISR).
    Tried half transfer and circular DMA buffer instead of DBM.  No
      change.  I think this is expected - DBM and Circular are probably
      implemented with the same logic except Circular updates always
      from M0AR.
4/12
    Observations
        While playing the khan segment, I got 7 FIFO underruns.  But that was over the course of many seconds.
        Do I just have an electrical issue?  Like when enough of the chip fires at once, I get a brownout?
	    That would explain the noise while the CPU is operating.
	    The noise is just brightness variations and not loss of pixels or sync.

4/11
    VTOR - vector table TBLOFF
    putting VTOR in SRAM1 didn't do anything
    while(1) WFI nor WFE did anything

4/10
    observations
        Here's a mystery: the porch value is 0x50, and that's at one voltage.  If I fill the color image with 0x50, that shows a slightly different voltage.

4/9
    observations
        glitch happens on line proportional to work done for the line (for the next line?)
        on YIQ images, glitch happens at the same horizontal location (because YIQ work is constant length per line)
        on lines with no work at low clocks rates, perfect color lock.
        better at lower clocks, worse at higher clocks, so is there a glitch happening in the colorburst at higher clocks?  Earlier per frame?
        Almost EVERYTHING is in CCM RAM now, except for font.  Could maybe copy into CCM but getting tight on stack.
        Drawing lk.ppm, suddenly switches from red to green or green to blue, or about 90 degrees, implying one missed transfer.
            So the DMA couldn't get memory for N cycles?  Or the GPIO stalled long enough to miss?

Video modes
    80x24 text at 8x16 is 640x384
    80x24 text at 8x8 is 640x192
    underscan rects
        one rect is 196, 830, 44, 236 (shorter but wider) - PROBABLY CHOOSE THIS ONE
            to be /4, use 196, 828, 44, 236
            636 by 192, 122112 pixels in frame, 15264 bytes at 1-bit monochrome
                Apple 2 560x192 DHGR would fit in here
            318 double pixels wide, 61056 pixels in frame
            159 quad pixels wide, 30528 pixels in frame
        one rect is 209, 819, 40, 244 (slightly narrower but taller)
            to be /4, use 208, 820, 40, 244
            612 by 204, 124848 pixels in frame, 15606 bytes at 1-bit monochrome
                could get by with 512 x 200 in this mode
                Apple 2 560x192 DHGR would fit in here
            306 double pixels wide, 62424 pixels in frame
            153 quad pixels wide, 31212 pixels in frame 
        to get to 640 for 80x8 font, could do 196, 832, 44, 236
            height of font has to also be 8 at 192 pixels tall (matches Apple 2)
    overscan rect is 167, 862, 27, 257
        to be /4, 164, 864, 27, 257
        700 x 230, 20125 bytes at 1-bit monochome
        350 double pixels wide, 80500 pixels in frame, would need to be 4-bit
        175 quad pixels wide, 40250 pixels in frame, could support 8 bit

for reference, H is 63555.56us

221 capacitor is 220 pF / .22 nF
    3x = .66 nF
332 capacitor is 3300 pF / 3.3 nF
    So 1 nF or 2 nF might be nice intermediate
    2x would be 1.5 nF

Need database of video field formats
    VCR, Apple //e, Video tape, Look at Channel F output from VCR
    Want %H of each segment and voltage
        Number of first EQ burst (e.g. 0 or 6)
        Number of VSYNC bursts a la VCR and NTSC standard (e.g. 0 or 6)
        Number of VSYNC lines a la Apple //e (e.g. 4 or 0)
        Whether VSYNC lines have colorburst
        Number of second EQ burst (e.g. 0 or 6)
        Regular lines: sync pulse, back porch, location and count of colorbursts, front porch
        number of blank lines before, number of blank lines after
    "video {fcc1953, vcr, apple2e, tape, channelf}"

# Notes

So I now remember sort of that the Mikro has its own bootloader (?) which can only be used with the Mikro downloader EXE.  Does the Mikro not expose BOOT0?  I had made my own board out of an unmodified STM32 exposing BOOT0 on the crazy big protoboard.  I can downloading using "make burn", which calls dfu-util.

optimize Wolf Row more
    Measured taking between 86% and 92% of frame at 400 pixels
        at 200MHz I have HCLKs clocks per row.  Assume 10% on clearing pixels, 11488 HCLKs, so between 25 and 27 clocks per pixel; you're not going to get any faster.
    You should MIPmaps for quality but you're probably not thrashing cache, and that's going to slow you down.
    Maybe go to 2X pixels and 350 samples - can maybe MIPmap.

Why is there purple where there should be brown? -> palette setting failure?  Clamping in YIQ calculations?
    looks like a DAC issue - switch from 0x7F to 0x80 is a big voltage drop
    Assume this would get fixed with .1% tolerance resistors (or even 1% tolerance)

objdump - dump all sections:
    /Users/grantham/packages/gcc-arm-none-eabi-7-2018-q2-update/bin/arm-none-eabi-objdump -x main.elf
objdump - Sort regions 0x2000000 - 0x2000ffff by size (sort of, key not quite right)
    /Users/grantham/packages/gcc-arm-none-eabi-7-2018-q2-update/bin/arm-none-eabi-objdump -x main.elf | egrep ^2000 | sort -n -k 1.22,1.80

glitching appears no different if nothing is in CCM.  :(

NTSC was not stable with internal oscillator without correction - could not nail down correction

What *are* the time bases for all TIM?  It seems like I can't get this right.
    the specs seem to point out correct behavior for TIMPRE.
    Also can verify the results in the CubeMX timing configurator.

enum Timer {
    TIM1 = 0, TIM2, TIM3, TIM4, TIM5, TIM6, TIM7, TIM8,
    TIM9, TIM10, TIM11, TIM12, TIM13, TIM14, TIM15,
};

int GetTIMxFrequency(Timer timer, int TIMPRE, int PPRE1, int PPRE2, int HCLKFrequency, int APB1Frequency, int APB2Frequency)
{
    int APBDomain;
    switch(timer) {
        case TIM2: case TIM3: case TIM4: case TIM5: case TIM6: case TIM7: case TIM12: case TIM13: case TIM14:
            APBDomain = 1; break;
        case TIM1: case TIM8: case TIM9: case TIM10: case TIM11: 
            APBDomain = 2; break;
    }

    int PPRE = (APBDomain == 1) ? PPRE1: PPRE2;
    int APBFrequency = (APBDomain == 1) ? APBFrequency1: APBFrequency2;

    if(TIMPRE == 0) {
        if(PPRE == 1) {
            return APBFrequency;
        } else {
            return APBFrequency * 2;
        }
    } else /* TIMPRE == 1 */ {
        if((PPRE == 1) || (PPRE == 2) || (PPRE == 4)) {
            return HCLKFrequency;
        } else {
            return APBFrequency * 4;
        }
    }
}

/* No faster than memcpy?  Because tight loop executes as fast as DMA? */
void MemoryCopyDMA(unsigned char* dst, unsigned char* src, size_t size)
{
    // XXX wait on previous DMA
    // Configure DMA to copy tmp row
    DMA2_Stream1->CR &= ~DMA_SxCR_EN;       /* disable DMA2_1 */
    DMA2->LIFCR = 0xF00;                        /* clear flags */
    DMA2_Stream1->NDTR = size / 4;
    DMA2_Stream1->PAR = (uint32_t)src;        // Source buffer address 0 in Memory-to-Memory mode
    DMA2_Stream1->M0AR = (uint32_t)dst;        // Dest buffer address in Memory-to-Memory mode
    DMA2_Stream1->FCR = DMA_FIFOMODE_ENABLE |   // Enable FIFO to improve stutter
        DMA_FIFO_THRESHOLD_FULL;        
    DMA2_Stream1->CR =
        DMA_CHANNEL_1 |                         
        DMA_MEMORY_TO_MEMORY |                  // Memory to Memory
        DMA_PDATAALIGN_WORD | // DMA_PBURST_INC4 |
        DMA_MDATAALIGN_WORD | // DMA_MBURST_INC4 |
        DMA_PRIORITY_LOW |
        DMA_PINC_ENABLE |                       // Increment memory address
        DMA_MINC_ENABLE |                       // Increment memory address
        0;
    DMA2_Stream1->CR |= DMA_SxCR_EN;    /* enable DMA */
} 

May 14: Strange bands of color May 14 is caused by DAC; verified
by running segtest monochrome with gradient 0 to 1

May 14: Weird aliasing that looks like I'm rendering at 1/4 res may
be caused by TV; verified by running segtest monochrome with gradient
0 to 1; grayscale images do not show bad aliasing.

May 22: C++
    * make_unique and unique_ptr work - verified within local block
    * #include <iostream> adds 200K to the executable - works, but avoid
    * exceptions work...!?
    * new and delete work, including try-catch bad_alloc
    * static constructed objects work
    * std::nothrow works - new returns 0
    * https://gist.github.com/bradgrantham/371f77dc2060fa4ad2fbe67940e4f7f6
