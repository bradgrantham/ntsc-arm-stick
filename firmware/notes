Close on segmented framebuffer
    What screen approach?
        1) defer all triangles
            N * 3 * ScreenVertex(4 + 4 + 3 + 2?) = N * 39, then still have to sort, then (2) or (3)
            only need one scanline of unmerged segments-with-depth around for 2
            still need to keep complete screen of segments-without-depth for SetScanlines style API
                460 * sqrt(N)-ish * Segment(7 * 2) = sqrt(N) * 6440, then still have to merge
            But one pass, top to bottom, output each SegmentWithDepth complete
        2) triangles into sorted per-line segment list with depth, merge segments as rasterized
            460 * sqrt(N)-ish * SegmentWithDepth(9 * 2) = sqrt(N) * 8280
            Make SetScanlines take SegmentWithDepth and discard the depth
        If N < 2226, (1) uses less memory, else (2) uses less memory
            32KB of deferred triangles is only like 1000 triangles anyway.
            Teapot is 576 triangles
            Polytope64 is 244 triangles
            Polytope256 is 1012 triangles
            So (1).
            But 1000 triangles (evenly distributed sqrt(N) * segment) is 261836 bytes?  Yikes!
        Therefore defer and then create screen one scanline at a time top to bottom, filling in VideoSegmentedScanline
    triangle to trapezoids (gradient, textured, solid)
    trapezoid to segments (gradient, textured, solid)
    clear screen is initial segments at depth = 0xffff
    SetSegmentTextured
    SetSegmentSolid
    PaintSegments
    handle gradient, textured, solid in SetScanlines
    set aspect ratio in Segmented mode and honor in segtest
Special nasty truecolor FB mode, 16 bits per pixel, Y8I4Q4? 100K RAM plus 50K VRAM: 320 x 240?
Move Wolf to palette-RGB-style textures (reduce bandwidth to make up lookup & process cost?)
honor aspect ratio in "show"
Some things to improve in "show"
    [--gray] - use a grayscale palette
    [N] - use mode N
Move to C++
Move to part with less ROM and more RAM, run by loading program into RAM
Need some confidence I can run at 250MHz or higher, then choose a crystal and PLL configuration to nail 14.31818MHz at ~250MHz that can also nail it somewhere more in the acceptable clock range 200-216MHz
    But 250MHz would give 20% more CPU availability to video modes or processing
Make circle renderer find pixel center coordinates to see if the weird jumpiness is being caused by integer snapping - can't expect decent lit or textured rendering if the coordinates are going to jump around for some reason
DB-9 Coleco game controller
PS/2 keyboard
imgBuffer should be called VRAM or something
paletteToWave and rowPalette should be carved from imgBuffer so imgBuffer for non-palette modes has more space
Some things to improve living
    tab should autocomplete at CLI
        tab in first completes commands
        tab in second et al completes filenames
    textport should be virtual and overlaid on screen in text mode and preserved for returning to text mode
        so then textport output would ALWAYS work and be recorded, and switching back to text would restore the old viewport.
        40 vs 80?  - just always 80?  (Could maybe get to 106x60 chars with 5x7 wide at 480p)
        make a scrollback buffer (what are the keyboard controls to scroll back?)
        3 pages of 80x24 = 5760 bytes, need to keep in RAM somewhere
    Factor out shell
    system button kicks back to text 0?
        or at least pops textport while button is down
        need a way to interrupt
        need a way to cancel and return from apps - longjmp?
    frame stats should be a histogram
        get TIM frequency nailed down
    serial and keyboard should interrupt and fill one buffer
    image viewer should add together lines and pixels so data is antialiased
Potential improvements
    use SDMMC peripheral
    There really should be a non-interlaced video mode
DCT video mode - make it so JPG blocks can be the source of the video scanout
MP3 player - target something simple and straightforward, like 128, 160, and 256 constant bitrate joint-stereo.
hosted
    move to OutputPutChar
    No separate console access, e.g. serial port; operate like standalone machine
    CLI/apps in other thread
        queues for output chars...?
        video and audio calls take a lock
        video scanout happens 30 Hz and also takes the lock
How to wrap up with a bow?
    board with 415 or 745 and microSD, two DB9s, PS/2 keyboard, NTSC composite out, mono Line-out, USB in for power and programming and stick an FTDI for UART?
    Be able to demo
        Wolfenstein
        ColecoVision
        microray
        show
        3D Spin
        play sound (in background?)
    Leave *potential* to hook Channel F 9-pin to DB9s
        potentially run Channel F
    Blog post
    Build docs
    API docs
Regularize I/O, get keyboard and serial combined into one queue
    OutputPutChar(int c);
Video API notes
    Fundamentally, CCMRAM lacks the memory for more than 1 byte per pixel at more than 250x200
        VideoMode has internals that convert to the display specifics
        VideoMode is the abstraction hiding the memory limitations from the application.
            Platform libraries do additional useful work, like converting R8G8B8 rows to 256-entry palettized images with Floyd-Steinberg
        Carve out 128K from 320K in 746, could easily have 512 * 240 * 256 colors
        Larger chip with 512K, could spare 256K, yield 640x400
        ** BUT part of the *novelty* of the project is that video is generated at a higher resolution than RAM allows. **
            e.g. very small palettes - 1, 2, 4 bit; RLE; DCT; specialized renderer (e.g. Wolfenstein, spin)
    NTSC output is by necessity Waves (DAC samples represent NTSC waveform at 14.31818 MHZ)
        Probably not much point in having R8G8B8 at 912 pixels per row - can't be represented
        So need to filter at least chroma down to 3.58MHz - Gaussian of 5 samples?  Could do box filter for start
            yiq can range from 
        Individual VideoModes could filter, or just the ones I care about could filter
        SET_AND_INCREMENT_WAVE(y, i, q)
    Commit to 565 for VGA output, use 3 DACs (and a whole 16-bit port?  Yikes!)
        *might* be able to convert 332 to FS-dithered at scan time
        Hook up to Parallax 332 DAC to start (and maybe dither), create 565 DAC later
    HDMI can be whatever as long as I have 3 bytes of RGB to look up in a table
clean up rect mode
setup a software interrupt for VBlank processing (e.g. update scanout stats, audio goop) and trigger it from row=262 and row = 525 -> event interrupt?
help and other output should be paged -
    have a special mode in non-VT102 mode?  Start Paging / Stop Paging?
    OutputSetPaging(int paging)
Move NTSC goop to another .c
Move Audio goop to another .c
Add some things to shell
    startup.sh # run from disk, quit scripting on blue button
    # run from a file
        will recursion work the way you've set it up?
    # parse between "" as one word
    # break commands on ";" outside ""
    # ignore everything after '#' outside ""
    sleep floatseconds # easy
    # variables - "$var"?
    menu var menufile # show a menu, return the option chosen in var
    getchar [var] # get a single character
    read [var] # get everything up to ENTER
    echo everything afterwards is echoed # easy
    # pixmap only :
        palette N r g b
        circle N x y r
        line N x0 y0 x1 y1
        clear N
    # expressions
    for var = A to B [step C] ; ... ; end
    for var in A B C D E F G ; ... ; end
VideoModeGetInfo should take a type so it can avoid copying wrong struct
everything should return 0 on success or non-zero error or void if it can't fail
audio
    22050Hz?  11025Hz?  8000Hz?
    write audio sample immediately on entry to line ISR?  Then calculate next one right after that, then do video calculation?
        Then audio resampling would happen at the line rate for whatever video mode is current...
    Do DMA at 22050 from double-buffered 512-byte buffers?  Could conflict with video but should be able to set priority lower.
    stereo audio output?
    audio modes:
        MIXED: add a finite-length U8 with arbitrary sample rate to the stream, audio processing will add up all active ones
        DIRECT: app callback to fill a buffer at a rate given to the callback
    does there need to be a mix in the DIRECT mode for things like beep, etc?
vile sucks, figure it out or replace it; issues:
    #dd doesn't work
    O and o behave weirdly
    0 does not go to the beginning of the line
    a and then enter does not scroll down
    #G uses line numbers off by one - is this termios?
VT102 handling (in combination with vile) doesn't handle inserting a line?
would be nice if video modes could have multiple submodes
    pixmap *and* text for last 4 rows
    wolfenstein *and* pixmap for bottom stats *and* upper-left small pixmap or text for FPS
special segment mode - 320 pixels wide (so 640 clocks, 2 clocks wide)
    app
        transforms lit, gouraud triangles to screen
        intersect scanlines with triangles
            output list of scanline edges
            do intersection and clipping of edges in depth
            sort in X including background
    video mode
        walks segments in turn assuming they touch all pixels
        interpolating, what?  RGB probably too slow - HSV?
        test program = circle
    Look up texture?  May be too hard to do perspective correction?
Should debug overlay XOR or just have black background?
    find pixel under and set white or black based on that?
Get DB9 joystick working
    uint32_t InputGetJoystickDir(int whichJoy) // flags or'd ; JOYSTICK_LEFT, etc
    uint32_t InputGetJoystickButton(int whichJoy) // flags or'd ; JOYSTICK_BUTTON0, JOYSTICK_BUTTON1, etc
    get Coleco joystick working
Raycaster game!
    monsters come after you, can be shot, inflict damage within certain range
    need sprites for powerups, monsters other goop
    gun
    bottom row shows health, points
    health powerups?
    put texture on ceiling and floor
video needs a "switching" mode
    old mode -> blank (fillrow does black) -> new mode
PS/2 mouse?
"Apps"
    Threading?
        all system functions have to be thread-safe...  Wrap locks around them
        then need scheduler
        if multiple apps can run simultaneously, then pipes would work
    malloc()/free() and fopen()/fclose() should probably be #defined to SysMalloc() and SysFOpen, etc, to be logged and then cleaned up on thread exit
    Can rename sections with objcopy (e.g. .data to .lessapp_data)
        Can single .c's be compiled into apps?
        then could prefix main() with startup code to copy .data, clear bss, then clean up on return from main
        could even have a way to receive a signal asynchronously, unwind stack, jump to exit code
    Should have a POSIX harness for running and testing the apps
        at least one of all video modes for testing
    System APIs that Apps can call
        OS/stdlib calls
            putchar?  getchar?
            malloc, free, etc
            fopen, fclose, etc
        video mode and config (NTSC vs VGA handled by hard board switch)
        serial port control
        register vblank handler
        get time and sleep
        audio mode and config
        get keyboard input
        read DB9 joystick
        layered facilities
            textport
            VT102 terminal processing (on textport)
                essentially just init() and putchar()
            graphics routines
    Wolfenstein
    3D viewer
    BASIC
    movie player... ? Targeted to full-screen 8-bit pixmap?  palette per frame?
    CP/M emulation
    Colecovision
    Apple2e
    WeFAX decoder
Additional video modes
    TMS 9918A mode - expose the chip I/O
        TMS pixels area is 192 lines high
    Apple //e mode - give pointers to memory and soft switches
    DCT mode
    scanline edge rendered mode - make RGB-to-byte as fast as possible
Channel F emulator, 9pin header adapters (bake into controller for Bart)
    need 16 pins for two controllers!
Colecovision emulator
Some kind of 3D uberdemo, realtime scan out, buffer of sorted scanline segments?
BASIC
    just implement 80x24 text mode for now
    video N # set video mode N
    lut c, r, g, b # calculate lut entry c for int r, g, b
    plot x, y, c    # plot pixel x, y with lut c
    line x0, y0, x1, y1, c # plot line
    clear c # clear screen to LUT color
    text N # text mode
    split {0,1} # split screen graphics and text (dependent on the modes?)
    handle a bunch of old BASIC programs like STARTREK, WUMPUS, ...?
    implement lunar lander
    Life: https://www.atariarchives.org/basicgames/showpage.php?page=100
        https://github.com/rricharz/R65/blob/master/Basic/life.bas
    Lunar Lander: https://www.atariarchives.org/basicgames/showpage.php?page=106
        http://vintage-basic.net/bcg/lunar.bas
    Sine Wave: https://www.atariarchives.org/basicgames/showpage.php?page=146
        http://www.vintage-basic.net/bcg/sinewave.bas
    Super Star Trek: https://www.atariarchives.org/basicgames/showpage.php?page=157
    3D Plot: https://www.atariarchives.org/basicgames/showpage.php?page=167
        http://vintage-basic.net/bcg/3dplot.bas


4/13
    On a hunch that maybe AHB doesn't do uchar writes directly and
      instead fetched a long, masked, or'd, and wrote a long, I tried
      doing word writes to GPIOC->ODR from DMA.  This would
      have been very inconvenient (altering ALL of GPIOC at once) but
      also would have meant using much more memory (a uint32_t per
      sample even though only 8 bits are used).  It didn't help, and
      in fact seemed worse.  Color didn't lock, jitter seemed as
      bad as uchar, and fillRowBuffer took MUCH longer (like 50% of the ISR).
    Tried half transfer and circular DMA buffer instead of DBM.  No
      change.  I think this is expected - DBM and Circular are probably
      implemented with the same logic except Circular updates always
      from M0AR.
4/12
    Observations
        While playing the khan segment, I got 7 FIFO underruns.  But that was over the course of many seconds.
        Do I just have an electrical issue?  Like when enough of the chip fires at once, I get a brownout?
	    That would explain the noise while the CPU is operating.
	    The noise is just brightness variations and not loss of pixels or sync.

4/11
    VTOR - vector table TBLOFF
    putting VTOR in SRAM1 didn't do anything
    while(1) WFI nor WFE did anything

4/10
    observations
        Here's a mystery: the porch value is 0x50, and that's at one voltage.  If I fill the color image with 0x50, that shows a slightly different voltage.

4/9
    observations
        glitch happens on line proportional to work done for the line (for the next line?)
        on YIQ images, glitch happens at the same horizontal location (because YIQ work is constant length per line)
        on lines with no work at low clocks rates, perfect color lock.
        better at lower clocks, worse at higher clocks, so is there a glitch happening in the colorburst at higher clocks?  Earlier per frame?
        Almost EVERYTHING is in CCM RAM now, except for font.  Could maybe copy into CCM but getting tight on stack.
        Drawing lk.ppm, suddenly switches from red to green or green to blue, or about 90 degrees, implying one missed transfer.
            So the DMA couldn't get memory for N cycles?  Or the GPIO stalled long enough to miss?

Video modes
    80x24 text at 8x16 is 640x384
    80x24 text at 8x8 is 640x192
    underscan rects
        one rect is 196, 830, 44, 236 (shorter but wider) - PROBABLY CHOOSE THIS ONE
            to be /4, use 196, 828, 44, 236
            636 by 192, 122112 pixels in frame, 15264 bytes at 1-bit monochrome
                Apple 2 560x192 DHGR would fit in here
            318 double pixels wide, 61056 pixels in frame
            159 quad pixels wide, 30528 pixels in frame
        one rect is 209, 819, 40, 244 (slightly narrower but taller)
            to be /4, use 208, 820, 40, 244
            612 by 204, 124848 pixels in frame, 15606 bytes at 1-bit monochrome
                could get by with 512 x 200 in this mode
                Apple 2 560x192 DHGR would fit in here
            306 double pixels wide, 62424 pixels in frame
            153 quad pixels wide, 31212 pixels in frame 
        to get to 640 for 80x8 font, could do 196, 832, 44, 236
            height of font has to also be 8 at 192 pixels tall (matches Apple 2)
    overscan rect is 167, 862, 27, 257
        to be /4, 164, 864, 27, 257
        700 x 230, 20125 bytes at 1-bit monochome
        350 double pixels wide, 80500 pixels in frame, would need to be 4-bit
        175 quad pixels wide, 40250 pixels in frame, could support 8 bit

for reference, H is 63555.56us
Scope only locks to my video at line #5

221 capacitor is 220 pF / .22 nF
    3x = .66 nF
332 capacitor is 3300 pF / 3.3 nF
    So 1 nF or 2 nF might be nice intermediate
    2x would be 1.5 nF

Need database of video field formats
    VCR, Apple //e, Video tape, Look at Channel F output from VCR
    Want %H of each segment and voltage
        Number of first EQ burst (e.g. 0 or 6)
        Number of VSYNC bursts a la VCR and NTSC standard (e.g. 0 or 6)
        Number of VSYNC lines a la Apple //e (e.g. 4 or 0)
        Whether VSYNC lines have colorburst
        Number of second EQ burst (e.g. 0 or 6)
        Regular lines: sync pulse, back porch, location and count of colorbursts, front porch
        number of blank lines before, number of blank lines after
    "video {fcc1953, vcr, apple2e, tape, channelf}"

# Notes

So I now remember sort of that the Mikro has its own bootloader (?) which can only be used with the Mikro downloader EXE.  Does the Mikro not expose BOOT0?  I had made my own board out of an unmodified STM32 exposing BOOT0 on the crazy big protoboard.  I can downloading using "make burn", which calls dfu-util.

optimize Wolf Row more
    Measured taking between 86% and 92% of frame at 400 pixels
        at 200MHz I have HCLKs clocks per row.  Assume 10% on clearing pixels, 11488 HCLKs, so between 25 and 27 clocks per pixel; you're not going to get any faster.
    You should MIPmaps for quality but you're probably not thrashing cache, and that's going to slow you down.
    Maybe go to 2X pixels and 350 samples - can maybe MIPmap.

interlaced?  Does there need to be a non-interlaced vs interlaced mode?
    let VideoMode handle it in width, height, and aspect
    Then rowNumber to FillRow functions sequential line number?  so lineNumber = 262 is half the end of odd field, half the beginning of even field?
        240P modes would render lineNumber for odd field, lineNumber - 263 for even field
        480i modes would calculate lineNumber * 2 as rowNumber for even field, or (lineNumber 263) * 2 + 1 as rowNumber for odd field
        line 263 through 264 are handled specially by rowFill (copying in half of the next line)x
    implementation (starting from line 0)
        line 262 - overwrite last 405 samples with first 405 samples of EQ pulse
        lines 263, 264 - last 405 of eq pulse then first 405 of eq pulse
        lines 265 - last 405 of eq pulse then first 405 of vsync
        lines 266, 267 - last 405 of vsync then first 405 of vsync
        lines 268 - last 405 of vsync then first 405 of eq pulse
        lines 269, 270 - last 405 of eq pulse then first 405 of eq pulse
        line 271 - last 405 of eq pulse then 405 of SyncPorch
        special line 282 - write SyncPorch fron BackPorch to middle of line after mode's fillRow()
        fix all fillRows to handle row > 250

Why is there purple where there should be brown? -> palette setting failure?  Clamping in YIQ calculations?
    looks like a DAC issue - switch from 0x7F to 0x80 is a big voltage drop
    Assume this would get fixed with .1% tolerance resistors (or even 1% tolerance)

objdump - dump all sections:
    /Users/grantham/packages/gcc-arm-none-eabi-7-2018-q2-update/bin/arm-none-eabi-objdump -x main.elf
objdump - Sort regions 0x2000000 - 0x2000ffff by size (sort of, key not quite right)
    /Users/grantham/packages/gcc-arm-none-eabi-7-2018-q2-update/bin/arm-none-eabi-objdump -x main.elf | egrep ^2000 | sort -n -k 1.22,1.80

glitching appears no different if nothing is in CCM.  :(

NTSC was not stable with internal oscillator without correction - could not nail down correction

Should NTSC modes take an RGB and use some kind of optimized lookup of 4 pixels at a time?
    I couldn't figure out a way for this to be done in one scanline's time
    If DVDs really have 700 vertical lines resolution, what do they do when going to Composite?

What *are* the time bases for all TIM?  It seems like I can't get this right.
    the specs seem to point out correct behavior for TIMPRE.
    Also can verify the results in the CubeMX timing configurator.

Is the 746 actually running at 1/2 the clock I think it is?
    I don't think so
        now clocks.py DMA_BEATS output is correct
        the image is stable
        UART works
        SysClock output matches what I expect
        MCO2 outputting PLL / 5 yields 40MHz on the scope, which is 1/5 of 200 MHz

Does DMA fire on one edge or both?  Why do I have to /2 the TIM ARR for the 746?
    Because I had a higher divider for APB2, where TIM1 lives

speed issues - seems to be like 60%-80% speed of 415.  Should be 160% the speed of 415.
    ICache and DCache are disabled on boot
    ICache improves speed to more like what I expect.
    DCache causes video modes to fail.  UART still worked, so system booted and partially worked...  Need to look into the data cache.

enum Timer {
    TIM1 = 0, TIM2, TIM3, TIM4, TIM5, TIM6, TIM7, TIM8,
    TIM9, TIM10, TIM11, TIM12, TIM13, TIM14, TIM15,
};

int GetTIMxFrequency(Timer timer, int TIMPRE, int PPRE1, int PPRE2, int HCLKFrequency, int APB1Frequency, int APB2Frequency)
{
    int APBDomain;
    switch(timer) {
        case TIM2: case TIM3: case TIM4: case TIM5: case TIM6: case TIM7: case TIM12: case TIM13: case TIM14:
            APBDomain = 1; break;
        case TIM1: case TIM8: case TIM9: case TIM10: case TIM11: 
            APBDomain = 2; break;
    }

    int PPRE = (APBDomain == 1) ? PPRE1: PPRE2;
    int APBFrequency = (APBDomain == 1) ? APBFrequency1: APBFrequency2;

    if(TIMPRE == 0) {
        if(PPRE == 1) {
            return APBFrequency;
        } else {
            return APBFrequency * 2;
        }
    } else /* TIMPRE == 1 */ {
        if((PPRE == 1) || (PPRE == 2) || (PPRE == 4)) {
            return HCLKFrequency;
        } else {
            return APBFrequency * 4;
        }
    }
}

May 14: Strange bands of color May 14 is caused by DAC; verified
by running segtest monochrome with gradient 0 to 1

May 14: Weird aliasing that looks like I'm rendering at 1/4 res may
be caused by TV; verified by running segtest monochrome with gradient
0 to 1; grayscale images do not show bad aliasing.

May 22: C++
    * make_unique and unique_ptr work - verified within local block
    * #include <iostream> adds 200K to the executable - works, but avoid
    * exceptions work...!?
    * new and delete work, including try-catch bad_alloc
    * static constructed objects work
    * std::nothrow works - new returns 0
    * https://gist.github.com/bradgrantham/371f77dc2060fa4ad2fbe67940e4f7f6
