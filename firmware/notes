Rein it in
    go figure out underscan, overscan left, right, width, height
    video modes
        underscan/overscan 4-cycle 256 colors (res?)
        underscan/overscan 2-cycle 4 grays  (res?)
        underscan/overscan byte HAM  (res?)
        monochrome 80x24 text - Apple font?
        color text? - 8x16 font?
    BASIC
        video N # set video mode N
        lut c, r, g, b # calculate lut entry c for int r, g, b
        plot x, y, c    # plot pixel x, y with lut c
        line x0, y0, x1, y1, c # plot line
        clear c # clear screen to LUT color
        text N # text mode
        split {0,1} # split screen graphics and text (dependent on the modes?)
        handle a bunch of old BASIC programs like STARTREK, WUMPUS, ...?
        implement lunar lander
    Channel F emulator, 9pin headers (bake into controller for Bart)
    Colecovision emulator, 9pin
    Fuzix? Or should I just import "sh"?
    Some kind of 3D uberdemo, realtime scan out, buffer of sorted scanline segments?
    Wrap up

What does going nuts look like?
    export internal FAT as USB (button or command switches modes)
    loadable executables - UNIX-y
    network over usb
    stereo audio output
    1/8inch jack audio input can decode WeFAX or MFSK

4/12
    Observations
        While playing the khan segment, I got 7 FIFO underruns.  But that was over the course of many seconds
        Do I just have an electrical issue?  Like when enough of the chip fires at once, I get a brownout?
	    That would explain the noise while the CPU is operating.
	    The noise is just brightness variations and not loss of pixels or sync.

4/11
    VTOR - vector table TBLOFF
    putting VTOR in SRAM1 didn't do anything
    while(1) WFI nor WFE did anything

4/10
    observations
        Here's a mystery: the porch value is 0x50, and that's at one voltage.  If I fill the color image with 0x50, that shows a slightly different voltage.

4/9
    observations
        glitch happens on line proportional to work done for the line (for the next line?)
        on YIQ images, glitch happens at the same horizontal location (because YIQ work is constant length per line)
        on lines with no work at low clocks rates, perfect color lock.
        better at lower clocks, worse at higher clocks, so is there a glitch happening in the colorburst at higher clocks?  Earlier per frame?
        Almost EVERYTHING is in CCM RAM now, except for font.  Could maybe copy into CCM but getting tight on stack.
        Drawing lk.ppm, suddenly switches from red to green or green to blue, or about 90 degrees, implying one missed transfer.
            So the DMA couldn't get memory for N cycles?  Or the GPIO stalled long enough to miss?

struct VideoModeInfo {
    unsigned char* baseAddress;
    enum Kind { PALETTIZED, TEXTPORT }; /* GAMEFIELD (sprite + background)
    int width, height; /* pixels or text */
    size_t rowSize; /* bytes */
    enum PixelFormat { BITMAP, GRAY_4BIT, GRAY_8BIT, PALETTE_4BIT, PALETTE_8BIT} pixelFormat;
    /* pixels are LSB, so 4BIT pixel N is in byte N/2 bits 0-3, and pixel N+1 is in byte N/2 bits 4-7 */
    uint32_t paletteSize; /* for convenience, matches pixelFormat */
    int color; /* for convenience, matches pixelFormat */
};

int getVideoModeCount();
int getVideoModeInfo(int n, VideoModeInfo *info);
int setPaletteEntryF(int a, float r, float g, float b); /* 0 if out of range, 1 if success */
int setPaletteEntry(int a, unsigned char r, unsigned char g, unsigned char b); /* 0 if out of range, 1 if success */
int setPixel(int x, int y, int c);
int setText(int x, int y, int c); /* might offset */

for reference, H is 63555.56us
Scope only locks to my video at line #5

221 capacitor is 220 pF / .22 nF
    3x = .66 nF
332 capacitor is 3300 pF / 3.3 nF
    So 1 nF or 2 nF might be nice intermediate
    2x would be 1.5 nF

Need database of video field formats
    VCR, Apple //e, Video tape, Look at Channel F output from VCR
    Want %H of each segment and voltage
        Number of first EQ burst (e.g. 0 or 6)
        Number of VSYNC bursts a la VCR and NTSC standard (e.g. 0 or 6)
        Number of VSYNC lines a la Apple //e (e.g. 4 or 0)
        Whether VSYNC lines have colorburst
        Number of second EQ burst (e.g. 0 or 6)
        Regular lines: sync pulse, back porch, location and count of colorbursts, front porch
        number of blank lines before, number of blank lines after
    "video {fcc1953, vcr, apple2e, tape, channelf}"

To Do
    Clean up breadboard - prevent wires from being yanked 
        make video connector a little less precarious somehow
        scope testpoints
    Read PPMs
        grayscale at 200x200 by 1 byte
        grayscale at 400x200 by 1 nybble
        color PPMs ? 
        palettized PPMs (how does that work?) at 200x200 by 1 byte,
            convert RGB palette to lookup table into 32 bit wave value
    if you can't get color figured out, jump ship
    audio - 22050?
        double buffering with realtime mixing?
        test with YMs
    Make into wired breadboard
        want different chip?  SRAM on the side?
        option to drive NTSC DAC or VGA 
    Design PCB, send off
    do a ray-tracing or other demo
    clean up current CLI - tableize with function and help
    embed a basic or scripting language
        read and write files
        MicroPython?
    factor out video formats somehow
        generalized beam-tracing framework
            per-row functions
            525 function pointers? (2K)
            swap DMA buffer pointers for EQ and VSYNC and not just copy stuff around
                But all functions get a 910-element buffer?
        give a shot at decompressing JPEG blocks in RT
        some modes will need to be exclusive because of memory size
            e.g. 200x200 palettized mode vs 400x400 bitmap mode
        interlaced mode
        monochrome 80 character text mode
        Apple //e video mode per row
            allow loading 0x2000 blobs
            HGR, GR? TEXT? 80TEXT? DHGR? DGR?
        Channel F video mode
    Apple //e emulation
    Z80 / CP/M emulation
    Channel F emulation
    ColecoVision emulation

So I now remember sort of that the Mikro has its own bootloader (?)
which can only be used with the Mikro downloader EXE.  Does the
Mikro not expose BOOT0?  I had made my own board out of an unmodified
STM32 exposing BOOT0 on the crazy big protoboard.  I can downloading using
"make burn", which calls dfu-util.
